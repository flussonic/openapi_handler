{
  "openapi": "3.1.0",
  "info": {
    "contact": {
      "email": "support@flussonic.com",
      "name": "Support team",
      "url": "https://flussonic.com/"
    },
    "description": "This document is a comprehensive API specification for the Flussonic Media Server.\n\nThe Flussonic Media Server API lets you manage the server configuration: retrieving the information about the streams, DVRs, templates, etc., \ncreating/updating, and removing them.\nTo know more about our API's design principles, visit [Flussonic HTTP API](https://flussonic.com/doc/api/flussonic-http-api/) page.\n\nPermanent [download link](https://flussonic.com/doc/api/reference.json) to JSON schema file.\n\nThis API Reference provides you with all the methods, fields, values, and endpoints currently accessible in Flussonic.\n\nBefore you proceed, read the following information:\n\n* `server_config` represents the server configuration file. Our built-in config parser validates the configuration file structure \naccording to this specification.\n* Some API methods may send extra fields in responses, so your application must be ready to drop them;\n* Do not rely on undocumented fields in the responses as we may modify them at any moment.\n* In further updates of this document, some fields may become deprecated. Such fields will be scheduled for deletion with \n`x-delete-at` property with year and month, after which it will no longer exist.\n",
    "title": "Flussonic Media Server API",
    "version": "1.2.3"
  },
  "components": {
    "schemas": {
      "program_id": {
        "type": "integer",
        "minimum": 1,
        "maximum": 65535,
        "x-notice": "mpegts program number"
      },
      "ts_pid": {
        "maximum": 8191,
        "minimum": 0,
        "type": "integer"
      },
      "iso8601": {
        "type": "integer",
        "x-notice": "2016-07-08T09:04:46Z"
      },
      "psi_version": {
        "type": "integer",
        "minimum": 0,
        "maximum": 31
      },
      "loglevel": {
        "type": "string",
        "description": "The level of logging according to event importance. Several values separated by comma.",
        "example": "debug",
        "oneOf": [
          {
            "title": "None",
            "const": "none",
            "description": "Logging disabled."
          },
          {
            "title": "Debug",
            "const": "debug",
            "description": "Messages of all types are logged."
          },
          {
            "title": "Info",
            "const": "info",
            "description": "Log info messages."
          },
          {
            "title": "Notice",
            "const": "notice",
            "description": "Log notices."
          },
          {
            "title": "Warning",
            "const": "warning",
            "description": "Log warnings."
          },
          {
            "title": "Error",
            "const": "error",
            "description": "Log errors."
          },
          {
            "title": "Alert",
            "const": "alert",
            "description": "Log alerts."
          },
          {
            "title": "Critical",
            "const": "critical",
            "description": "Log critical messages."
          }
        ]
      },
      "binary_value": {
        "type": "string"
      },
      "binary_boolean": {
        "type": "string"
      },
      "collection_response": {
        "type": "object",
        "properties": {
          "estimated_count": {
            "description": "Estimated total number of records for the query (regardless of the cursors).\n",
            "type": "integer",
            "nullable": true,
            "example": 5
          },
          "next": {
            "description": "Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items. \nMore information can be found [here](https://flussonic.com/doc/api/flussonic-http-api/#limited-collections-access-cursors). \n",
            "example": "JTI0cG9zaXRpb25fZ3Q9MA==",
            "type": "string",
            "nullable": true
          },
          "prev": {
            "description": "Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items. \nMore information can be found [here](https://flussonic.com/doc/api/flussonic-http-api/#limited-collections-access-cursors).\n",
            "example": "JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl",
            "type": "string",
            "nullable": true
          },
          "timing": {
            "description": "An object with a list of different timings measured during this API call.",
            "type": "object",
            "nullable": true
          }
        }
      },
      "error_response": {
        "type": "object",
        "properties": {
          "errors": {
            "description": "List of structured errors",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/error"
            },
            "nullable": true
          }
        }
      },
      "error": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "nullable": true,
            "description": "a unique identifier for this particular occurrence of the problem\n"
          },
          "status": {
            "type": "string",
            "description": "the HTTP status code applicable to this problem, expressed as a string value\n"
          },
          "code": {
            "type": "string",
            "description": "an application-specific error code, expressed as a string value\n"
          },
          "title": {
            "type": "string",
            "nullable": true,
            "description": "a short, human-readable summary of the problem that SHOULD NOT change from\noccurrence to occurrence of the problem, except for purposes of localization\n"
          },
          "source": {
            "description": "an object containing references to the source of the error\n",
            "type": "object",
            "nullable": true,
            "properties": {
              "pointer": {
                "type": "string",
                "nullable": true,
                "description": "a JSON Pointer [RFC6901] to the associated entity in the request document \n[e.g. `\"/data\"` for a primary data object, or `\"/data/attributes/title\"` for a specific attribute].\n"
              },
              "parameter": {
                "type": "string",
                "nullable": true,
                "description": "a string indicating which URI query parameter caused the error."
              }
            }
          },
          "meta": {
            "type": "object",
            "description": "a meta object containing non-standard meta-information about the error.\n",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "thumbnails_spec": {
        "type": "object",
        "properties": {
          "url": {
            "description": "*Flussonic* takes a thumbnail from the specified URL on each keyframe.\nMay reduce CPU usage on IP cameras.\n",
            "type": "string",
            "nullable": true,
            "example": "http://10.115.23.45/isapi/thumbnail.jpg"
          },
          "enabled": {
            "description": "Whether to generate thumbnails from the video stream.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/thumbnails_enabled_spec"
              }
            ],
            "default": true
          },
          "sizes": {
            "description": "What sizes will be used for thumbnails generation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/thumbnails_size_spec"
            },
            "default": []
          }
        }
      },
      "thumbnails_enabled_spec": {
        "oneOf": [
          {
            "type": "boolean",
            "enum": [
              true,
              false
            ],
            "description": "Configures thumbnails behaviour.\n- true : \n\n    In case of Stream: \n      Thumbnails are created and stored in DVR during the recording. If thumbnail is requested then it will be returned from DVR.\n\n    In case of VOD:\n      Thumbnails are created and stored in VOD location at thumbnails folder during the VOD opening if they are not created yet.\n      If VOD location is `readonly` then it will be used only for thumbnails searching. Nothing will be created and stored.  \n\n      If thumbnail is requested then it will be returned from thumbnails folder in VOD location.\n\n- false : thumbnails are not stored at all. If thumbnail is requested then 403 'Forbidden' error will be returned.\n"
          },
          {
            "type": "string",
            "enum": [
              "ondemand"
            ],
            "description": "- ondemand : thumbnails are not stored at all. If thumbnail is requested then it will be generated from corresponding video frame.\n"
          }
        ]
      },
      "thumbnails_size_spec": {
        "type": "object",
        "properties": {
          "width": {
            "nullable": true,
            "type": "integer",
            "description": "The thumbnail width."
          },
          "height": {
            "nullable": true,
            "type": "integer",
            "description": "The thumbnail height."
          }
        }
      },
      "ad_placement": {
        "type": "string",
        "oneOf": [
          {
            "title": "Preroll",
            "const": "preroll",
            "description": "Path to the pre-roll video file (in VOD) to be shown before the main video."
          },
          {
            "title": "Midroll",
            "const": "midroll",
            "description": "Path to the mid-roll video file (in VOD) to be shown during the video according to the ad markers."
          }
        ],
        "description": "The advertising placement type."
      },
      "session_type": {
        "type": "string",
        "oneOf": [
          {
            "title": "Play",
            "const": "play",
            "description": "Some external app plays video from Media Server."
          },
          {
            "title": "Publish",
            "const": "publish",
            "description": "Some external app publishes video to Media Server."
          },
          {
            "title": "Ingest",
            "const": "ingest",
            "description": "Media Server ingests video from some external source like IPTV, IP camera, etc."
          },
          {
            "title": "Push",
            "const": "push",
            "description": "Media Server pushes video to some external app."
          },
          {
            "title": "Stream",
            "const": "stream",
            "description": "The session that can be parent to any number of `play`, `publish`, `push`, or `ingest` sessions.\nIt is designed to group several sessions each corresponding to one input. \n\nThe `stream` session doesn't have `parent_id`.\n"
          },
          {
            "title": "Muxer",
            "const": "muxer",
            "description": "The session for video pushed as part of MPTS (Multi Program Transport Stream). \nSeveral inputs are monitored in one session.\n"
          },
          {
            "title": "API",
            "const": "api",
            "description": "Session initiated via API."
          },
          {
            "title": "Player",
            "const": "player",
            "description": "The session opened in addition to `play` when Flussonic Player plays video from Media Server."
          },
          {
            "title": "Publisher",
            "const": "publisher",
            "description": "The session opened in addition to `publish` when the video is published to Media Server by Flussonic Publisher."
          }
        ]
      },
      "session_key": {
        "anyOf": [
          {
            "oneOf": [
              {
                "title": "IP",
                "const": "ip",
                "description": "IP address"
              },
              {
                "title": "Name",
                "const": "name",
                "description": "Stream name"
              },
              {
                "title": "Proto",
                "const": "proto",
                "description": "Protocol"
              },
              {
                "title": "Token",
                "const": "token",
                "description": "Token"
              }
            ],
            "type": "string"
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/session_key_query"
              }
            ]
          }
        ]
      },
      "session_status": {
        "oneOf": [
          {
            "title": "Establishing",
            "const": "establishing"
          },
          {
            "title": "Running",
            "const": "running"
          },
          {
            "title": "Stalling",
            "const": "stalling"
          },
          {
            "title": "Finished",
            "const": "finished"
          }
        ],
        "type": "string"
      },
      "protocol": {
        "type": "string",
        "oneOf": [
          {
            "title": "copy",
            "const": "copy"
          },
          {
            "title": "fake",
            "const": "fake"
          },
          {
            "title": "RTMP",
            "const": "rtmp"
          },
          {
            "title": "RTMPS",
            "const": "rtmps"
          },
          {
            "title": "RTMPE",
            "const": "rtmpe"
          },
          {
            "title": "RTSP",
            "const": "rtsp"
          },
          {
            "title": "RTSP-UDP",
            "const": "rtsp-udp"
          },
          {
            "title": "RTSP2",
            "const": "rtsp2"
          },
          {
            "title": "RTSPS",
            "const": "rtsps"
          },
          {
            "title": "EST",
            "const": "est"
          },
          {
            "title": "SRT",
            "const": "srt"
          },
          {
            "title": "MSE-LD",
            "const": "mseld"
          },
          {
            "title": "SHOUTcast",
            "const": "shoutcast"
          },
          {
            "title": "SHOUTcasts",
            "const": "shoutcasts"
          },
          {
            "title": "WebRTC",
            "const": "webrtc"
          },
          {
            "title": "HLS",
            "const": "hls"
          },
          {
            "title": "HLSS",
            "const": "hlss"
          },
          {
            "title": "HLS2",
            "const": "hls2"
          },
          {
            "title": "HLSS2",
            "const": "hlss2"
          },
          {
            "title": "LL-HLS",
            "const": "llhls"
          },
          {
            "title": "CMAF",
            "const": "cmaf"
          },
          {
            "title": "HLS DVR",
            "const": "hls_dvr"
          },
          {
            "title": "MSS DVR",
            "const": "mss_dvr"
          },
          {
            "title": "RTSP DVR",
            "const": "rtsp_dvr"
          },
          {
            "title": "HTTP MPEG-TS DVR",
            "const": "tshttp_dvr"
          },
          {
            "title": "DASH",
            "const": "dash"
          },
          {
            "title": "MSS",
            "const": "mss"
          },
          {
            "title": "M4S",
            "const": "m4s"
          },
          {
            "title": "M4SS",
            "const": "m4ss"
          },
          {
            "title": "M4F",
            "const": "m4f"
          },
          {
            "title": "M4FS",
            "const": "m4fs"
          },
          {
            "title": "HTTP MPEG-TS",
            "const": "tshttp"
          },
          {
            "title": "HTTPS MPEG-TS",
            "const": "tshttps"
          },
          {
            "title": "TCP MPEG-TS",
            "const": "tstcp"
          },
          {
            "title": "SSL MPEG-TS",
            "const": "tsssl"
          },
          {
            "title": "MKV",
            "const": "mkv"
          },
          {
            "title": "MKVS",
            "const": "mkvs"
          },
          {
            "title": "FLV",
            "const": "flv"
          },
          {
            "title": "annexB",
            "const": "annexb"
          },
          {
            "title": "UDP",
            "const": "udp"
          },
          {
            "title": "UDP1",
            "const": "udp1"
          },
          {
            "title": "UDP2",
            "const": "udp2"
          },
          {
            "title": "UDP3",
            "const": "udp3"
          },
          {
            "title": "UDP MPTS",
            "const": "mpts-udp"
          },
          {
            "title": "HTTP MPTS",
            "const": "mpts-http"
          },
          {
            "title": "HTTPS MPTS",
            "const": "mpts-https"
          },
          {
            "title": "DVB MPTS",
            "const": "mpts-dvb"
          },
          {
            "title": "DVB",
            "const": "dvb"
          },
          {
            "title": "Decklink",
            "const": "decklink"
          },
          {
            "title": "AJA",
            "const": "aja"
          },
          {
            "title": "DekTec",
            "const": "dektec"
          },
          {
            "title": "v4l",
            "const": "v4l"
          },
          {
            "title": "v4l2",
            "const": "v4l2"
          },
          {
            "title": "Playlist",
            "const": "playlist"
          },
          {
            "title": "Mixer",
            "const": "mixer"
          },
          {
            "title": "Mosaic",
            "const": "mosaic"
          },
          {
            "title": "Mosaic2",
            "const": "mosaic2"
          },
          {
            "title": "Timeshift",
            "const": "timeshift"
          },
          {
            "title": "File",
            "const": "file"
          },
          {
            "title": "Download",
            "const": "download"
          },
          {
            "title": "MBR",
            "const": "mbr"
          },
          {
            "title": "MP4",
            "const": "mp4"
          },
          {
            "title": "Logo",
            "const": "logo"
          },
          {
            "title": "JPEG",
            "const": "jpeg"
          },
          {
            "title": "MJPEG",
            "const": "mjpeg"
          },
          {
            "title": "H.323",
            "const": "h323"
          },
          {
            "title": "Ad injector",
            "const": "ad_injector"
          },
          {
            "title": "ffmpeg",
            "const": "ffmpeg"
          },
          {
            "title": "Transponder",
            "const": "transponder"
          },
          {
            "title": "API",
            "const": "api"
          },
          {
            "title": "JSON manifest",
            "const": "json_manifest"
          },
          {
            "title": "Player",
            "const": "player"
          }
        ]
      },
      "ssl_protocol": {
        "type": "string",
        "oneOf": [
          {
            "title": "TLSv1",
            "const": "tlsv1"
          },
          {
            "title": "TLSv1.1",
            "const": "tlsv1.1"
          },
          {
            "title": "TLSv1.2",
            "const": "tlsv1.2"
          }
        ]
      },
      "segments_container": {
        "type": "string",
        "oneOf": [
          {
            "title": "CMAF",
            "const": "cmaf"
          },
          {
            "title": "fMP4",
            "const": "fmp4"
          },
          {
            "title": "MPEG-TS",
            "const": "mpegts"
          }
        ]
      },
      "session_generic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier (or UUID) of the session.",
            "example": "61942414-8c15-4809-8bb6-adf1ae846027"
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/session_type"
              }
            ],
            "nullable": true,
            "example": "play",
            "description": "The type of the session."
          },
          "source_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "example": "61942420-1b2e-4614-8871-a4c6345da31f",
            "description": "Unique ID of the session's source."
          },
          "parent_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "example": "61942426-2501-4962-bbab-a612fd619495",
            "description": "ID of the parent session, used only for sessions with the stream/substream type"
          },
          "ip": {
            "type": "string",
            "nullable": true,
            "description": "IP address of the connected peer.",
            "example": "172.16.25.73"
          },
          "bytes": {
            "type": "integer",
            "format": "bytes",
            "default": 0,
            "description": "Number of bytes sent in the session."
          },
          "proto": {
            "allOf": [
              {
                "$ref": "#/components/schemas/protocol"
              }
            ],
            "nullable": true,
            "description": "Protocol used for the data transmission in the session.",
            "example": "dash"
          },
          "opened_at": {
            "type": "number",
            "format": "utc_ms",
            "nullable": true,
            "description": "The time when this session was created.",
            "example": 1637094994
          },
          "started_at": {
            "type": "number",
            "format": "utc_ms",
            "nullable": true,
            "description": "The time when the frames transmission started in the session.",
            "example": 1637095014
          },
          "updated_at": {
            "type": "number",
            "format": "utc_ms",
            "nullable": true,
            "description": "The time when the session was last updated.",
            "example": 1637098611
          },
          "closed_at": {
            "type": "number",
            "format": "utc_ms",
            "nullable": true,
            "description": "The time when the session was closed.",
            "example": 1637098821
          },
          "segments_container": {
            "allOf": [
              {
                "$ref": "#/components/schemas/segments_container"
              }
            ],
            "nullable": true,
            "description": "Media container used for this protocol.\nFor instance, HLS can go with MPEG-TS or fMP4 segments and DASH with big fMP4 or small CMAF segments.\n"
          },
          "ssl": {
            "type": "boolean",
            "nullable": true,
            "description": "This flag indicates that TLS (SSL) was used to serve this session.\nIt may be either input (ingest, publish) or output (push, play) session, this flag will be\nfilled for any of them.\n"
          },
          "ssl_protocol": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ssl_protocol"
              }
            ],
            "nullable": true,
            "description": "SSL Protocol version.",
            "example": "tlsv1.2"
          },
          "dvr": {
            "type": "boolean",
            "nullable": true,
            "description": "This flag indicates that this session was using DVR.\n"
          }
        }
      },
      "session_details": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "media_name",
            "nullable": true,
            "description": "File used in the streaming session.",
            "example": "hockey1"
          },
          "token": {
            "type": "string",
            "format": "session_token",
            "nullable": true,
            "description": "Token provided by the client.",
            "example": "zGAFxLkoWluO1pG7_nJmQAbCnM5"
          },
          "country": {
            "type": "string",
            "format": "iso3166",
            "nullable": true,
            "description": "Peer's IP geolocation (country).",
            "example": "us"
          },
          "user_id": {
            "type": "string",
            "nullable": true,
            "description": "User ID provided by the Middleware authorization backend.",
            "example": "5435"
          },
          "max_sessions": {
            "type": "integer",
            "nullable": true,
            "description": "The maximum number of sessions allowed for the given `user_id` by the middleware authorization backend."
          },
          "soft_limitation": {
            "type": "boolean",
            "default": false,
            "description": "The flag shows if the soft limitation mode is enabled for the sessions with the given `user_id`."
          },
          "user_name": {
            "type": "string",
            "format": "media_name",
            "nullable": true,
            "description": "User-provided original stream/VOD name before the rewrite of a media [*aliaser*](https://flussonic.com/doc/video-playback/media-name-aliasing/)."
          },
          "referer": {
            "type": "string",
            "format": "url",
            "nullable": true,
            "description": "Referer HTTP header or its analog for other protocols.",
            "example": "http://my-tv-portal.local/hockey1"
          },
          "query_string": {
            "type": "string",
            "nullable": true,
            "description": "Full query string for the initial request of the session."
          },
          "current_time": {
            "type": "number",
            "format": "milliseconds",
            "nullable": true,
            "description": "The current time value of the playback session."
          },
          "user_agent": {
            "type": "string",
            "nullable": true,
            "description": "Client's user agent for selected protocol.",
            "example": "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36"
          }
        }
      },
      "session": {
        "allOf": [
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/session_details"
          },
          {
            "$ref": "#/components/schemas/session_player"
          }
        ]
      },
      "session_player": {
        "type": "object",
        "properties": {}
      },
      "playback_headers": {
        "type": "object",
        "properties": {
          "playback": {
            "type": "string",
            "description": "Playback type for which the HTTP headers apply.",
            "nullable": true,
            "oneOf": [
              {
                "title": "Live",
                "const": "live"
              },
              {
                "title": "DVR",
                "const": "dvr"
              }
            ],
            "example": "live"
          },
          "protocols": {
            "description": "Configuration to allow/forbid headers for various playback protocols.",
            "allOf": [
              {
                "$ref": "#/components/schemas/play_protocols_spec"
              }
            ],
            "nullable": true
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "string",
            "nullable": true,
            "description": "HTTP headers in name-value format for manifest requests.",
            "example": {
              "Cache-Control": "max-age=3600"
            }
          },
          "segment_headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "string",
            "nullable": true,
            "description": "HTTP headers in name-value format for segment requests.",
            "example": {
              "Cache-Control": "max-age=3600"
            }
          }
        }
      },
      "flow_type": {
        "enum": [
          "file",
          "stream",
          "dvr_file",
          "dvr_stream"
        ],
        "type": "string"
      },
      "frame_video_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "H.264",
            "const": "h264"
          },
          {
            "title": "HEVC (H.265)",
            "const": "hevc"
          },
          {
            "title": "MP2V",
            "const": "mp2v"
          },
          {
            "title": "VP9",
            "const": "vp9"
          },
          {
            "title": "VP8",
            "const": "vp8"
          },
          {
            "title": "MJPEG",
            "const": "mjpeg"
          },
          {
            "title": "Screen",
            "const": "screen"
          },
          {
            "title": "JPEG",
            "const": "jpeg"
          },
          {
            "title": "AV1",
            "const": "av1"
          }
        ]
      },
      "frame_audio_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "AAC",
            "const": "aac"
          },
          {
            "title": "MP3",
            "const": "mp3"
          },
          {
            "title": "MP2A",
            "const": "mp2a"
          },
          {
            "title": "Opus",
            "const": "opus"
          },
          {
            "title": "AC3",
            "const": "ac3"
          },
          {
            "title": "EAC3",
            "const": "eac3"
          },
          {
            "title": "PCMA",
            "const": "pcma"
          },
          {
            "title": "PCMU",
            "const": "pcmu"
          }
        ]
      },
      "frame_text_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "TTXT",
            "const": "ttxt"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "WVTT",
            "const": "wvtt"
          },
          {
            "title": "TTML",
            "const": "ttml"
          },
          {
            "title": "Subtitle",
            "const": "subtitle"
          },
          {
            "title": "ID3T",
            "const": "id3t"
          },
          {
            "title": "ONVIF",
            "const": "onvif"
          },
          {
            "title": "TX3G",
            "const": "tx3g"
          }
        ]
      },
      "frame_raw_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV",
            "const": "yuv"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "YUV422p10",
            "const": "yuv422p10"
          },
          {
            "title": "ARGB",
            "const": "argb"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "PCM",
            "const": "pcm"
          }
        ]
      },
      "frame_app_codec": {
        "oneOf": [
          {
            "title": "MPEG-TS",
            "const": "mpegts"
          },
          {
            "title": "Object",
            "const": "object"
          },
          {
            "title": "EIT",
            "const": "eit"
          },
          {
            "title": "SCTE-27",
            "const": "scte27"
          },
          {
            "title": "SCTE-35",
            "const": "scte35"
          },
          {
            "title": "Empty",
            "const": "empty"
          }
        ],
        "type": "string"
      },
      "frame_codec": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/frame_video_codec"
          },
          {
            "$ref": "#/components/schemas/frame_audio_codec"
          },
          {
            "$ref": "#/components/schemas/frame_raw_codec"
          },
          {
            "$ref": "#/components/schemas/frame_text_codec"
          },
          {
            "$ref": "#/components/schemas/frame_app_codec"
          }
        ]
      },
      "frame_content": {
        "type": "string",
        "oneOf": [
          {
            "title": "Audio",
            "const": "audio"
          },
          {
            "title": "Video",
            "const": "video"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "Metadata",
            "const": "metadata"
          },
          {
            "title": "Application",
            "const": "application"
          }
        ]
      },
      "frame_video_pix_fmt": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV420P",
            "const": "yuv420p"
          },
          {
            "title": "YUVJ420P",
            "const": "yuvj420p"
          },
          {
            "title": "YUV422P",
            "const": "yuv422p"
          },
          {
            "title": "YUV444P",
            "const": "yuv444p"
          },
          {
            "title": "YUV420P10",
            "const": "yuv420p10"
          },
          {
            "title": "YUV422P10",
            "const": "yuv422p10"
          },
          {
            "title": "YUV444P10",
            "const": "yuv444p10"
          },
          {
            "title": "YUV420P12",
            "const": "yuv420p12"
          },
          {
            "title": "YUV422P12",
            "const": "yuv422p12"
          },
          {
            "title": "YUV444P12",
            "const": "yuv444p12"
          },
          {
            "title": "Gray8",
            "const": "gray8"
          },
          {
            "title": "Gray10",
            "const": "gray10"
          },
          {
            "title": "Gray12",
            "const": "gray12"
          },
          {
            "title": "NV12",
            "const": "nv12"
          },
          {
            "title": "P016",
            "const": "p016"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "ARGB",
            "const": "argb"
          }
        ]
      },
      "track_info": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "$ref": "#/components/schemas/track_info_audio"
          },
          {
            "$ref": "#/components/schemas/track_info_video"
          },
          {
            "$ref": "#/components/schemas/track_info_video_configurable"
          }
        ]
      },
      "track_info_base": {
        "type": "object",
        "properties": {
          "track_id": {
            "description": "Track identifier assigned by Flussonic.",
            "nullable": true,
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "example": "v1"
          },
          "frame_duration": {
            "description": "For video track, it is the time between the beginning of a frame and the beginning of the next frame.\n\nThis parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.\nHowever, sometimes (when the connection is broken) video breakups are possible.\nAs result, the delta between two consequent frame timestamps will not be equal to the frame duration.\nThis situation is considered as a frame gap and is handled differently across different protocols.\n",
            "type": "number",
            "format": "ticks",
            "nullable": true
          },
          "last_gop": {
            "description": "Last GOP size (expressed in number of frames).\nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems. \nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "nullable": true,
            "type": "integer",
            "example": 28
          },
          "avg_gop": {
            "nullable": true,
            "type": "integer",
            "description": "Average GOP size (expressed in number of frames) of the last 1000-2000 frames. \nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems. \nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "example": 25
          },
          "avg_fps": {
            "description": "Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).\nThe higher FPS is, the smoother the video playback is. \nUsually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).\n",
            "nullable": true,
            "type": "number",
            "x-notice": "calculated fps for statistic"
          },
          "closed_captions": {
            "description": "Parameters of closed captions.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/closed_captions"
                }
              ]
            },
            "type": "array",
            "default": []
          }
        }
      },
      "track_info_base_configurable": {
        "type": "object",
        "properties": {
          "content": {
            "description": "Content of the track (audio, video, or text).",
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_content"
              }
            ]
          },
          "title": {
            "description": "Human-readable localized title of the track.",
            "nullable": true,
            "type": "string",
            "x-notice": "Human-readable localized title for HDS/HLS",
            "example": "Video1"
          },
          "codec": {
            "description": "Codec of the track. Different codecs do **not** get the same track.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_codec"
              }
            ]
          },
          "bitrate": {
            "description": "Bitrate of the track.",
            "nullable": true,
            "type": "integer",
            "format": "speed",
            "example": 2543
          },
          "language": {
            "description": "Language value of the track, if applicable.",
            "nullable": true,
            "type": "string",
            "example": "eng"
          },
          "bframes": {
            "description": "Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.\nB-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.\nThis value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.\n",
            "nullable": true,
            "type": "integer",
            "x-notice": "calculated number of bframes for statistic",
            "example": 3
          },
          "gop_size": {
            "description": "The number of frames in a group of pictures (GOP). \nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\nA bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)\n",
            "nullable": true,
            "type": "integer"
          },
          "pid": {
            "description": "This parameter sets PIDs values for outgoing MPEG-TS streams. \nPID identifies separate data stream inside the multiplexed MPEG-TS stream. \nIt is possible to set PID values for PMT, SDT, video, and audio tracks. \nTracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track. \n\nIt is possible to set the base index for the tracks of a certain type using the 0 (zero) index. \nFor example, t0=100 sets PID=101 for the first track, 102 for the second, and so on. \nNumbers can be given in decimal form (by default) or hexadecimal with 16# prefix.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ]
          }
        }
      },
      "track_info_video": {
        "type": "object",
        "properties": {
          "length_size": {
            "enum": [
              2,
              4
            ],
            "default": 4,
            "type": "integer",
            "x-notice": "H264 private option",
            "description": "The size of the length field for H264 bitstream without start codes."
          }
        }
      },
      "track_info_video_configurable": {
        "type": "object",
        "properties": {
          "width": {
            "description": "The picture width in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "nullable": true
          },
          "height": {
            "description": "The picture height in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "nullable": true
          },
          "fps": {
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\nHigher frame rates capture more images per second, which makes for smoother video.\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames). \n",
            "nullable": true,
            "type": "number"
          },
          "pix_fmt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_video_pix_fmt"
              }
            ],
            "default": "yuv420p",
            "description": "The color model of the video."
          },
          "num_refs_frames": {
            "type": "integer",
            "maximum": 32,
            "minimum": 0,
            "nullable": true,
            "description": "The number of I-frames to be used for encoding."
          },
          "sar_width": {
            "description": "The first number in SAR - the ratio of the width of the display video representation to the width of the pixel representation.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            }
          },
          "sar_height": {
            "description": "The second number in SAR - the ratio of the width of the display video representation to the width of the pixel representation.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            }
          },
          "pixel_width": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "nullable": true
          },
          "pixel_height": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "nullable": true
          },
          "level": {
            "type": "string",
            "nullable": true,
            "description": "A set of constraints that indicate a degree of required decoder performance.\nThis parameter is used for compatibility with old devices.\n"
          },
          "profile": {
            "description": "A specific codec-dependent profile of the output video.\nThe profile allows to assume if the track can be played on a particular device.\n",
            "type": "string",
            "nullable": true
          }
        }
      },
      "track_info_audio": {
        "type": "object",
        "properties": {
          "channels": {
            "description": "The number of audio channels.",
            "nullable": true,
            "type": "integer",
            "example": 2
          },
          "sample_rate": {
            "description": "Sample rate, in hertz -\nthe number of samples per second taken from a continuous signal to make a discrete or digital signal.\n",
            "nullable": true,
            "type": "integer",
            "example": 8000
          }
        }
      },
      "closed_captions": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language of closed captions.",
            "type": "string",
            "nullable": true,
            "example": "eng"
          },
          "name": {
            "description": "Under what name the audio track will be displayed on the player.",
            "type": "string",
            "nullable": true,
            "example": "English"
          }
        }
      },
      "media_info": {
        "type": "object",
        "properties": {
          "flow_type": {
            "description": "Whether it is a file with a finite start and end time or a live stream.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/flow_type"
              }
            ],
            "example": "stream"
          },
          "stream_id": {
            "nullable": true,
            "type": "integer",
            "x-notice": "Will be used as ts_stream_id in mpegts",
            "example": 253,
            "description": "The identifier of the transport stream for MPEG TS streams."
          },
          "program_id": {
            "nullable": true,
            "type": "integer",
            "x-notice": "Will be used as program id",
            "example": 110,
            "description": "The program ID for MPEG TS streams."
          },
          "tracks": {
            "description": "Information about available tracks (video, audio, or text).",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/track_info"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "duration": {
            "type": "number",
            "format": "ticks",
            "description": "Duration of the media, if applicable.",
            "nullable": true
          },
          "provider": {
            "description": "The media provider.",
            "nullable": true,
            "type": "string",
            "example": "Netflix"
          },
          "title": {
            "description": "Human-readable title of the media.",
            "nullable": true,
            "type": "string",
            "example": "Bunny"
          }
        }
      },
      "transcoder_track_info": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "$ref": "#/components/schemas/track_info_audio"
          },
          {
            "$ref": "#/components/schemas/transcoder_track_info_audio"
          },
          {
            "$ref": "#/components/schemas/transcoder_track_info_video"
          }
        ]
      },
      "transcoder_track_info_audio": {
        "type": "object",
        "properties": {
          "input_track": {
            "description": "Input track to be transcoded.\n",
            "nullable": true,
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "example": "a1"
          },
          "async": {
            "description": "Resample the input audio to the specified parameters, using the libswresample library (`aresample` option of `ffmpeg`).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://ffmpeg.org/ffmpeg-filters.html#aresample-1"
            },
            "nullable": true,
            "type": "integer",
            "deprecated": true
          },
          "input_sample_rate": {
            "description": "Audio input sample rate.\nUsually, it is autodetected but in some cases, e.g., for HE-AAC coding, we cannot get it correctly, so define manually.\n",
            "nullable": true,
            "type": "integer",
            "deprecated": true
          },
          "volume": {
            "description": "Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).\n\nIf it is just an integer or a float, the output audio volume is calculated by this formula:\n\n`output_volume = volume * input_volume`\n\nIf specified in decibels (dB), the output audio volume is calculated as follows:\n\n`output_volume = input_volume +/- volume`\n\ndepending whether it is a positive (+9dB) or a negative value (-6dB).\n\nBy default it equals to 1 (the input audio volume).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/how-to-change-the-volume-level"
            },
            "nullable": true,
            "type": "string",
            "example": "-6dB"
          },
          "split_channels": {
            "description": "This option allows to split each audio track with multiple channels into several mono tracks.\n",
            "nullable": true,
            "type": "boolean",
            "default": false
          }
        }
      },
      "transcoder_track_info_video": {
        "type": "object",
        "properties": {
          "preset": {
            "description": "A set of values that determine a certain encoding speed, which influences a compression ratio. \nA slower preset will provide better compression (compression is quality per file size).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/#transcoder-preset"
            },
            "nullable": true,
            "default": "veryfast",
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_preset"
              }
            ],
            "example": "medium"
          },
          "profile": {
            "description": "Limits the output to a specific H.264 profile.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_profile"
              }
            ]
          },
          "level": {
            "description": "A set of constraints that indicate a degree of required decoder performance.\nThis parameter is used for compatibility with old devices.\n",
            "nullable": true,
            "anyOf": [
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/h264_level"
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/hevc_level"
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/mp2v_level"
                  }
                ]
              }
            ]
          },
          "size": {
            "description": "Target size of the image and the strategy to achieve it.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_size"
              }
            ]
          },
          "sar": {
            "description": "Target aspect ratio.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_sar"
              }
            ]
          },
          "logo": {
            "description": "The configuration of a logo \"burned\" into the video track.\nThe transcoder adds the logo before the video is resized as specified in the `size` option. \nThis means that the logo can be visibly stretched if the size was changed significantly.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_logo"
              }
            ]
          },
          "alogo": {
            "description": "The configuration of a logo added to the video track after the video was resized as specified in the `size` option.\n\nThis prevents the logo picture from stretching that might occur when the `logo` option is used. \nYou will need to prepare and specify a separate file with a logo for each size of the resulting video track.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_logo"
              }
            ]
          },
          "fps": {
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\n\nHigher frame rates capture more images per second, which makes for smoother video.\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_fps"
              }
            ]
          },
          "refs": {
            "description": "The number of reference frames in a GOP.\nReference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).\n",
            "nullable": true,
            "maximum": 6,
            "minimum": 1,
            "type": "integer"
          },
          "gop": {
            "description": "Sets the number of frames in a GOP.\nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\n",
            "nullable": true,
            "type": "integer",
            "example": 150
          },
          "qp_range": {
            "description": "The ranges of the quantization parameter for different types of frames in a GOP.\n\nQuantization is an algorithm used for video compression. It is based on fragmentation of video frames.\nIncreasing this parameter allows to improve the compression but may lower the picture quality.\nUsually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_qp_range"
              }
            ]
          },
          "threads": {
            "description": "Number of threads used by the decoder when transcoding with CPU (it is not used for other types of transcoder).\nThis parameter allows to increase performance by adding new threads. By default, it is autodetected.\n",
            "nullable": true,
            "type": "integer"
          },
          "open_gop": {
            "description": "Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.\nIt allows to decrease bitrate to 5-7%, but can result in breaking the picture.\n",
            "default": false,
            "type": "boolean"
          },
          "interlace": {
            "description": "This parameter is used to get an interlaced stream from a progressive one.\nThe allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/interlace_settings"
              }
            ]
          },
          "rc_method": {
            "description": "A method for creating output video with constant bitrate suitable for broadcasting to television networks.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            },
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/rc_method"
              }
            ]
          },
          "temporal_tradeoff": {
            "description": "Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.\nThe allowed values are: \n\n* `15` - drop 1 from 5\n* `13` - drop 1 from 3\n* `12` - drop 1 from 2\n* `23` - drop 2 from 3\n* `0` - do not drop frames\n",
            "nullable": true,
            "type": "integer"
          },
          "vbv_bufsize": {
            "description": "Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.\n",
            "nullable": true,
            "type": "integer"
          },
          "resize_mode": {
            "description": "The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:\n\n* vic -  Video Image Converter, specific for Jetson Nvidia\n* cuda - CUDA (or Compute Unified Device Architecture)\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_resize_mode"
              }
            ]
          },
          "burn": {
            "description": "Configuration of burn-in text, timestamp, or subtitles to video frames.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_burn"
              }
            ]
          },
          "extra": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true,
            "description": "Some additional options."
          }
        }
      },
      "webrtc_prefer_codec": {
        "type": "string",
        "enum": [
          "h264",
          "vp8",
          "vp9",
          "av1"
        ]
      },
      "webrtc_transport": {
        "type": "string",
        "enum": [
          "udp",
          "tcp"
        ]
      },
      "output_audio": {
        "type": "string",
        "oneOf": [
          {
            "title": "Keep",
            "const": "keep",
            "description": "Keep the original audio codec."
          },
          {
            "title": "AAC",
            "const": "aac",
            "description": "Keep AAC if available or transcode to AAC; delete other tracks if any."
          },
          {
            "title": "Add_AAC",
            "const": "add_aac",
            "description": "Add AAC if it was not available already while keeping the original track."
          }
        ]
      },
      "h264_level": {
        "enum": [
          "1",
          "1b",
          "1.1",
          "1.2",
          "1.3",
          "2",
          "2.1",
          "2.2",
          "3",
          "3.0",
          "3.1",
          "3.2",
          "4",
          "4.0",
          "4.1",
          "4.2",
          "5",
          "5.1",
          "5.2",
          "6",
          "6.1",
          "6.2"
        ],
        "type": "string"
      },
      "hevc_level": {
        "enum": [
          "1",
          "2",
          "2.1",
          "3",
          "3.1",
          "4",
          "4.1",
          "5",
          "5.1",
          "5.2",
          "6",
          "6.1",
          "6.2"
        ],
        "type": "string"
      },
      "mp2v_level": {
        "enum": [
          "low",
          "main",
          "high",
          "high1440"
        ],
        "type": "string"
      },
      "transcoder_device": {
        "enum": [
          "cpu",
          "qsv",
          "nvenc",
          "nvenc2",
          "coder",
          "omx",
          "l4t2"
        ],
        "type": "string"
      },
      "transcoder_device_stats": {
        "type": "object",
        "properties": {
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_device"
              }
            ],
            "nullable": true,
            "description": "The type of the device used for transcoding.",
            "example": "cpu"
          },
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_deviceid"
              }
            ],
            "nullable": true,
            "description": "The ID of the device used for transcoding.\n\nIn PUT requests, you can use `auto` for Flussonic to set the ID itself. \nIn the response to GET requests, the `id` will always be a number.\n"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "The name of the transcoder device."
          },
          "can_logo": {
            "type": "boolean",
            "nullable": true,
            "description": "Shows if the device can put a logo on the image."
          },
          "can_interlace": {
            "type": "boolean",
            "nullable": true,
            "description": "Shows if the device can make an interlaced stream from a progressive one."
          },
          "can_internal": {
            "type": "boolean",
            "nullable": true,
            "description": "Shows if the transcoder with this device can run in the same process as Flussonic Media Server."
          },
          "memTotal": {
            "type": "integer",
            "nullable": true,
            "description": "Total RAM on the device."
          },
          "memFree": {
            "type": "integer",
            "nullable": true,
            "description": "Free RAM."
          },
          "memUsed": {
            "type": "integer",
            "nullable": true,
            "description": "Utilized RAM."
          },
          "reconfig_support": {
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_reconfig_support"
              }
            ],
            "nullable": true,
            "description": "The ability of the device to be reconfigured online, i.e. without complete restart of the transcoder.\n\n`full` means that both decoder and encoder can be reconfigured online.\n`encoder` means that only encoder can be reconfigured online.\n`decoder` means that only decoder can be reconfigured online.\n`false` means that online reconfiguration is not supported.\n"
          },
          "gpu_temp": {
            "type": "integer",
            "nullable": true,
            "description": "GPU temperature, °C."
          },
          "gpu_enc": {
            "type": "integer",
            "nullable": true,
            "description": "GPU encoder load percentage."
          },
          "gpu_dec": {
            "type": "integer",
            "nullable": true,
            "description": "GPU decoder load percentage."
          },
          "gpu_sm": {
            "type": "integer",
            "nullable": true,
            "description": "GPU shared memory amount."
          }
        }
      },
      "transcoder_resize_mode": {
        "enum": [
          "vic",
          "cuda"
        ],
        "type": "string"
      },
      "tc_bitrate": {
        "anyOf": [
          {
            "enum": [
              "copy"
            ],
            "type": "string"
          },
          {
            "type": "integer"
          }
        ]
      },
      "tc_reconfig_support": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "full",
              "decoder",
              "encoder"
            ]
          },
          {
            "type": "boolean",
            "enum": [
              false
            ]
          }
        ]
      },
      "tc_deviceid": {
        "anyOf": [
          {
            "enum": [
              "auto"
            ],
            "type": "string"
          },
          {
            "type": "integer"
          }
        ]
      },
      "tc_fps": {
        "anyOf": [
          {
            "enum": [
              "any",
              "auto"
            ],
            "type": "string"
          },
          {
            "type": "integer"
          }
        ]
      },
      "tc_preset": {
        "oneOf": [
          {
            "title": "Slow",
            "const": "slow"
          },
          {
            "title": "Medium",
            "const": "medium"
          },
          {
            "title": "Fast",
            "const": "fast"
          },
          {
            "title": "Very fast",
            "const": "veryfast"
          },
          {
            "title": "Ultra fast",
            "const": "ultrafast"
          }
        ],
        "type": "string"
      },
      "tc_profile": {
        "oneOf": [
          {
            "title": "Simple",
            "const": "simple"
          },
          {
            "title": "Baseline",
            "const": "baseline"
          },
          {
            "title": "Main",
            "const": "main"
          },
          {
            "title": "Main 10",
            "const": "main10"
          },
          {
            "title": "High",
            "const": "high"
          },
          {
            "title": "High 422",
            "const": "high422"
          },
          {
            "title": "High 444",
            "const": "high444"
          }
        ],
        "type": "string"
      },
      "rc_method": {
        "oneOf": [
          {
            "title": "VBR",
            "const": "vbr",
            "description": "The encoder will not encode a stream to be DVB compliant.\nHowever, VBR (Variable Bit Rate) produces better compression compared to CBR at about the same quality.\n"
          },
          {
            "title": "CBR",
            "const": "cbr",
            "description": "The encoder will produce a DVB compliant stream.\nThe bitrate of the output stream will be stable to fit the fixed-bandwidth channel. \nIn other words, we guarantee that the bitrate has a certain upper bound in a sliding window.\n"
          },
          {
            "title": "CBR2pass",
            "const": "cbr2pass",
            "description": "The encoder will encode the video once in CBR, \nthen it will encode it second time in CBR but using the information from the previous pass to improve quality.\n"
          }
        ],
        "type": "string"
      },
      "tc_label_box": {
        "type": "object",
        "properties": {
          "borderw": {
            "description": "The width, in pixel, of the border to be drawn around the text, timestamp, or subtitles.",
            "nullable": true,
            "type": "integer",
            "example": 10
          },
          "color": {
            "description": "Box color.",
            "nullable": true,
            "anyOf": [
              {
                "type": "string",
                "examples": [
                  "black",
                  "white"
                ]
              },
              {
                "type": "string",
                "format": "hexcolor",
                "example": "#d62d20"
              }
            ]
          },
          "alpha": {
            "description": "Box opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).",
            "nullable": true,
            "maximum": 1,
            "minimum": 0,
            "type": "number",
            "example": 0
          }
        }
      },
      "tc_label_font": {
        "type": "object",
        "properties": {
          "file": {
            "description": "The subpath to the `.ttf` font file in the `font` subdirectory of the `/etc/flussonic/` directory. \nThis means you can place the font file like `/etc/flussonic/font/SomeFont.ttf`.\n\nIf the font file specified is missing in `/etc/flussonic/font/`, the default `FiraCode-Regular.ttf` font will be used, which is included in Flussonic.\n\nYou can also specify the full path to a font file. Make sure you put the font file in the directory you specified. \n",
            "nullable": true,
            "type": "string",
            "example": "/usr/share/fonts/truetype/freefont/FONT_NAME.ttf"
          },
          "size": {
            "description": "The font size in pixel.",
            "nullable": true,
            "type": "integer",
            "example": 24
          },
          "color": {
            "description": "Font color.",
            "nullable": true,
            "anyOf": [
              {
                "type": "string",
                "examples": [
                  "black",
                  "white"
                ]
              },
              {
                "type": "string",
                "format": "hexcolor",
                "example": "#d62d20"
              }
            ]
          },
          "alpha": {
            "description": "Font opacity (use values from 0.1 to 1.0, 0.0 - completely transparent, 1.0 - completely opaque).",
            "nullable": true,
            "maximum": 1,
            "minimum": 0,
            "type": "number",
            "example": 1
          }
        }
      },
      "tc_label": {
        "type": "object",
        "properties": {
          "text": {
            "description": "Text, time, or subtitles to burn-in to video frames.\n\n* For text - it is the text\n* For subtitles - it is the subtitles track, e.g., `t1`.\n* For time - it is the time in one of the formats:\n** `%T` - the time in 24-hour notation (`%H:%M:%S`).\n** `%F` - equivalent to `%Y-%m-%d` (the ISO 8601 date format).\n",
            "nullable": true,
            "type": "string"
          },
          "x": {
            "description": "The offset of the text, timestamp, or subtitles position, in pixel, to the right or left to the center of the screen.",
            "nullable": true,
            "type": "integer"
          },
          "y": {
            "description": "The offset of the text, timestamp, or subtitles position, in pixel, up or down to the center of the screen.",
            "nullable": true,
            "type": "integer"
          },
          "position": {
            "description": "Position to burn text:\n- `tl` : Top left\n- `tr` : Top right\n- `bl` : Bottom left\n- `br` : Bottom right\n- `c` : Center\n- `ct` : Center top\n- `cb` : Center bottom\n",
            "nullable": true,
            "enum": [
              "tl",
              "bl",
              "tr",
              "br",
              "c",
              "ct",
              "cb"
            ],
            "type": "string"
          },
          "font": {
            "description": "Font to be used for text, timestamp, or subtitles burn-in to video frames.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_label_font"
              }
            ]
          },
          "box": {
            "description": "Parameters of the box around the text, timestamp, or subtitles.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_label_box"
              }
            ]
          }
        }
      },
      "tc_burn": {
        "type": "object",
        "properties": {
          "text": {
            "description": "Configuration of burn-in text to video frames. \n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_label"
              }
            ]
          },
          "time": {
            "description": "Configuration of burn-in timestamp to video frames. \n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_label"
              }
            ]
          },
          "sub": {
            "description": "Configuration of burn-in subtitles to video frames. \n",
            "nullable": true,
            "x-scope": [
              "flussonic",
              "cloud"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_label"
              }
            ]
          }
        }
      },
      "tc_global": {
        "type": "object",
        "properties": {
          "hw": {
            "description": "Transcoder hardware device type to be used for transcoding a stream.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_device"
              }
            ]
          },
          "deviceid": {
            "description": "Identifier of hardware device to be used for transcoding a stream.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_deviceid"
              }
            ]
          },
          "external": {
            "description": "If this parameter is se to `true` (by default), the transcoder runs in a separate process from Flussonic.\n\nIf it is set to `false`, the transcoder will run in the same process as Flussonic. \nThis mode speeds up encoding, especially when encoding audio or when using an Nvidia device. \nHowever, a transcoder error may cause Flussonic to crash.\n",
            "nullable": true,
            "type": "boolean"
          },
          "seamless": {
            "description": "Enable smooth, or seamless, source switching. \nIn this case, the transcoder seamlessly switches to another source format without dropping any frames when the stream source or the media information has changed. \n\nFor transcoding with CPU or Nvidia NVENC, seamless source switching is the default behavior.\nHowever, for other hardware transcoders (Intel Quick Sync) it might be necessary to configure the seamless source switching. \n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder/#smooth-source-switching"
            },
            "nullable": true,
            "type": "boolean",
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "gop": {
            "description": "GOP (group of pictures) size (in frames) to be applied for any video track in the stream.\nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\nMay be overridden for a track. \n",
            "nullable": true,
            "type": "integer",
            "example": 150
          },
          "burn": {
            "description": "Configuration of text, timestamp or subtitles burn-in to video frames. \n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_burn"
              }
            ]
          }
        }
      },
      "tc_crop": {
        "type": "object",
        "properties": {
          "left": {
            "description": "The `x` coordinate of the upper-left corner of the output video withing the input video.",
            "type": "integer"
          },
          "top": {
            "description": "The `y` coordinate of the upper-left corner of the output video withing the input video.",
            "type": "integer"
          },
          "width": {
            "description": "The width of the output video.",
            "type": "integer"
          },
          "height": {
            "description": "The height of the output video.",
            "type": "integer"
          }
        },
        "required": [
          "left",
          "top",
          "width",
          "height"
        ]
      },
      "deinterlace_settings": {
        "anyOf": [
          {
            "enum": [
              true
            ],
            "type": "boolean"
          },
          {
            "enum": [
              false
            ],
            "type": "boolean"
          },
          {
            "enum": [
              "adaptive",
              "yadif"
            ],
            "type": "string"
          }
        ]
      },
      "tc_decoder": {
        "type": "object",
        "properties": {
          "pix_fmt": {
            "description": "The required pixel format according to a color model.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_video_pix_fmt"
              }
            ]
          },
          "deinterlace": {
            "description": "Activate deinterlacing, i.e., converting an interlaced image to a progressive image. \nIt is necessary for comfortable viewing of legacy TV video on PC/mobile devices. You can use the following values:\n\n`true` - deinterlacing enabled\n`false` - deinterlacing disabled\n`adaptive` - use adaptive deinterlacing method\n`yadif` - use CUDA yadif deinterlacing method\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/deinterlace_settings"
              }
            ],
            "example": true
          },
          "deinterlace_rate": {
            "description": "This parameter is used when encoding with Nvidia NVENC.\nYou can remove duplicate frames that were produced after deinterlacing, preventing increased bitrate, by one of two methods:\n\n* `frame` - from field sequence `1a 1b 2a 2b 3a 3b` we get frame sequence `1a1b 2a2b 3a3b`. The FPS stays the same.\n* `field` - fields `1a 1b 2a 2b 3a 3b` transform into `1a1b 1b2a 2a2b 2b3a` frames. The FPS increases two times after transcoding.\n",
            "nullable": true,
            "enum": [
              "frame",
              "field"
            ],
            "type": "string",
            "example": "frame"
          },
          "threads": {
            "description": "Defines a number of threads in a decoder. One thread uses one core.",
            "nullable": true,
            "deprecated": true,
            "anyOf": [
              {
                "enum": [
                  "auto"
                ],
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "example": 2
          },
          "enable_audio_desync_comp": {
            "description": "If this option is enabled, the missed audio frames are compensated by the silence.\n",
            "nullable": true,
            "type": "boolean",
            "deprecated": true,
            "example": true
          },
          "dsurfaces": {
            "description": "This parameter is applicable for NVENC transcoder only.\nIt is the number of the buffers used by the decoder. A buffer allows to compensate different sizes of frames: \nif a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.\n\nThe default value is 16.\nYou can specify a value from 4 to 48 depending of the video card memory.\n",
            "nullable": true,
            "deprecated": true,
            "type": "integer",
            "example": 18
          },
          "gen_pts": {
            "description": "Enable generation of PTS (presentation time stamps) when using QSV transcoder.\n\nIf `gen_pts=no`, the PTS received from the decoder are used. \nIn some cases, it could result in unsynced audio and video. \nSo this parameter was implemented for better audio and video synchronization.\n",
            "nullable": true,
            "deprecated": true,
            "type": "boolean",
            "example": true
          },
          "crop": {
            "description": "Video cropping options.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_crop"
              }
            ]
          },
          "drop_frame_interval": {
            "description": "This parameter is applicable for NVIDIA Jetson transcoder only.\nThis is the number of frames after wich the decoder skips a frame and, thus, allows to save the resources. For example:\n\n* 1 - sip each frame\n* 2 - skip each second frame\n* 3 - skip each third frame, etc.\n\nThis option can be useful for streams with high FPS (e.g., 60) as it allows to increase the bandwidth.\n",
            "nullable": true,
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "example": 3
          },
          "no_dpb": {
            "description": "Switch off the decoded picture buffer. Works for the streams with 1 reference frame.\nThe default value is `false`.\n",
            "nullable": true,
            "type": "boolean",
            "example": false
          },
          "streaming_frame": {
            "description": "Allow receiving incomplete frames from the input buffer.\nIf it is set to `true`, the decoder can start decoding before the complete frame is received.\n",
            "nullable": true,
            "type": "boolean",
            "example": false
          }
        }
      },
      "tc_audio_opts": {
        "type": "object",
        "properties": {
          "bitrate": {
            "description": "Audio bitrate. The allowed values are:\n\n* `copy` - the bitrate or the original stream is copied to the outgoing stream.\n* a full number of bits (e.g., 64000) or a short form of the number with `k` (e.g., 64k).\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_bitrate"
              }
            ],
            "example": 96
          },
          "sample_rate": {
            "description": "Sample rate, in hertz - \nthe number of samples per second taken from a continuous signal to make a discrete or digital signal.\nThe allowed values are: \n`0` - to copy input sample rate, a number (input audio is resampled with equalization), or the empty value (equalization without resampling)\n",
            "nullable": true,
            "type": "integer",
            "example": 8000
          },
          "codec": {
            "description": "Audio codec (the AAC codec is used by default).",
            "nullable": true,
            "enum": [
              "aac",
              "opus",
              "mp2a",
              "ac3",
              "pcma"
            ],
            "type": "string",
            "example": "opus"
          },
          "channels": {
            "description": "The number of audio channels in an output stream.",
            "nullable": true,
            "type": "integer",
            "example": 2
          },
          "async": {
            "description": "Resample the input audio to the specified parameters, using the libswresample library (`aresample` option of `ffmpeg`).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://ffmpeg.org/ffmpeg-filters.html#aresample-1"
            },
            "nullable": true,
            "type": "integer",
            "deprecated": true
          },
          "air": {
            "description": "Audio input sample rate.\nUsually, it is autodetected but in some cases, e.g., for HE-AAC coding, we cannot get it correctly, so define manually.\n",
            "nullable": true,
            "type": "integer",
            "deprecated": true
          },
          "avol": {
            "description": "Output audio volume. The value can be specified in decibels (dB) or it can be an integer/float (3, 0.5, etc.).\n\nIf it is just an integer or a float, the output audio volume is calculated by this formula:\n\n`output_volume = avol * input_volume`\n\nIf specified in decibels (dB), the output audio volume is calculated as follows:\n\n`output_volume = input_volume +/- avol`\n\ndepending whether it is a positive (+9dB) or a negative value (-6dB).\n\nBy default it equals to 1 (the input audio volume).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/how-to-change-the-volume-level"
            },
            "nullable": true,
            "type": "string",
            "example": "-6dB"
          },
          "split_channels": {
            "description": "This option allows to split each audio track with multiple channels into several mono tracks.\n",
            "nullable": true,
            "type": "boolean",
            "default": false
          }
        }
      },
      "tc_size": {
        "type": "object",
        "properties": {
          "width": {
            "description": "The picture width in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "nullable": true,
            "type": "integer"
          },
          "height": {
            "description": "The picture height in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "nullable": true,
            "type": "integer"
          },
          "strategy": {
            "description": "The algorithm of the picture resizing: crop, scale, or fit.\n",
            "default": "fit",
            "enum": [
              "crop",
              "scale",
              "fit"
            ],
            "type": "string",
            "example": "crop"
          },
          "background": {
            "description": "The color of the area in the player that is not occupied by the video after resizing. \nIt is used only with the 'fit' strategy.\n",
            "nullable": true,
            "anyOf": [
              {
                "enum": [
                  "blur"
                ],
                "type": "string"
              },
              {
                "type": "string",
                "format": "hexcolor"
              }
            ]
          }
        }
      },
      "tc_sar": {
        "type": "object",
        "properties": {
          "x": {
            "description": "The first number in SAR - the ratio of the width of the display video representation to the width of the pixel representation.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            },
            "nullable": true,
            "type": "integer"
          },
          "y": {
            "description": "The second number in SAR - the ratio of the width of the display video representation to the width of the pixel representation.\n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            },
            "nullable": true,
            "type": "integer"
          }
        }
      },
      "tc_logo": {
        "type": "object",
        "properties": {
          "path": {
            "description": "Path to the logo image.",
            "nullable": true,
            "type": "string"
          },
          "x": {
            "description": "The offset of the logo position, in pixel, to the right or left to the center of the screen.",
            "nullable": true,
            "type": "integer"
          },
          "y": {
            "description": "The offset of the logo position, in pixel, up or down to the center of the screen.",
            "nullable": true,
            "type": "integer"
          },
          "position": {
            "description": "Position to place the logo:\n- `tl` : Top left\n- `tr` : Top right\n- `bl` : Bottom left\n- `br` : Bottom right\n- `c` : Center\n",
            "nullable": true,
            "enum": [
              "tl",
              "tr",
              "bl",
              "br",
              "c"
            ],
            "type": "string"
          }
        }
      },
      "tc_qp_range": {
        "type": "object",
        "properties": {
          "qpmini": {
            "description": "Minimal quantization parameter for I-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          },
          "qpmaxi": {
            "description": "Maximal quantization parameter for I-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          },
          "qpminp": {
            "description": "Minimal quantization parameter for P-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          },
          "qpmaxp": {
            "description": "Maximal quantization parameter for P-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          },
          "qpminb": {
            "description": "Minimal quantization parameter for B-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          },
          "qpmaxb": {
            "description": "Maximal quantization parameter for B-frames.",
            "nullable": true,
            "maximum": 100,
            "minimum": 0,
            "type": "integer"
          }
        }
      },
      "interlace_settings": {
        "anyOf": [
          {
            "enum": [
              false
            ],
            "type": "boolean"
          },
          {
            "enum": [
              "tff",
              "bff",
              "tff_separated",
              "bff_separated",
              "mbaff"
            ],
            "type": "string"
          },
          {
            "enum": [
              true
            ],
            "type": "boolean"
          }
        ]
      },
      "tc_video_opts": {
        "type": "object",
        "properties": {
          "track": {
            "description": "Number of a video track.",
            "type": "integer",
            "example": 1
          },
          "bitrate": {
            "description": "The bitrate of a video track.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_bitrate"
              }
            ],
            "example": 1000000
          },
          "codec": {
            "description": "The video codec.",
            "nullable": true,
            "default": "h264",
            "oneOf": [
              {
                "title": "H.264",
                "const": "h264"
              },
              {
                "title": "HEVC",
                "const": "hevc"
              },
              {
                "title": "AV1",
                "const": "av1"
              },
              {
                "title": "MP2V",
                "const": "mp2v"
              }
            ],
            "type": "string"
          },
          "preset": {
            "description": "A set of values that determine a certain encoding speed, which influences a compression ratio. \nA slower preset will provide better compression (compression is quality per file size).\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/#transcoder-preset"
            },
            "nullable": true,
            "default": "veryfast",
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_preset"
              }
            ],
            "example": "medium"
          },
          "profile": {
            "description": "Limits the output to a specific H.264 profile.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_profile"
              }
            ]
          },
          "level": {
            "description": "A set of constraints that indicate a degree of required decoder performance.\nThis parameter is used for compatibility with old devices.\n",
            "nullable": true,
            "anyOf": [
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/h264_level"
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/hevc_level"
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/mp2v_level"
                  }
                ]
              }
            ]
          },
          "size": {
            "description": "Target size of the image and the strategy to achieve it.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_size"
              }
            ]
          },
          "sar": {
            "description": "Target aspect ratio.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_sar"
              }
            ]
          },
          "logo": {
            "description": "The configuration of a logo \"burned\" into the video track.\nThe transcoder adds the logo before the video is resized as specified in the `size` option. \nThis means that the logo can be visibly stretched if the size was changed significantly.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_logo"
              }
            ]
          },
          "alogo": {
            "description": "The configuration of a logo added to the video track after the video was resized as specified in the `size` option.\n\nThis prevents the logo picture from stretching that might occur when the `logo` option is used. \nYou will need to prepare and specify a separate file with a logo for each size of the resulting video track.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_logo"
              }
            ]
          },
          "fps": {
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\n\nHigher frame rates capture more images per second, which makes for smoother video.\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_fps"
              }
            ]
          },
          "bframes": {
            "description": "Number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.\nB-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.\nThis value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.\n\nWhen set to 0, this option disables b-frames. This may be necessary, for example, when broadcasting to RTSP.\n",
            "nullable": true,
            "enum": [
              0,
              1,
              2,
              3,
              4
            ],
            "type": "integer",
            "example": 3
          },
          "refs": {
            "description": "The number of reference frames in a GOP.\nReference frames are frames of a compressed video that are used to define other frames (P-frames and B-frames).\n",
            "nullable": true,
            "maximum": 6,
            "minimum": 1,
            "type": "integer"
          },
          "gop": {
            "description": "Sets the number of frames in a GOP. \nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\n",
            "nullable": true,
            "type": "integer",
            "example": 150
          },
          "qp_range": {
            "description": "The ranges of the quantization parameter for different types of frames in a GOP.\n\nQuantization is an algorithm used for video compression. It is based on fragmentation of video frames.\nIncreasing this parameter allows to improve the compression but may lower the picture quality.\nUsually, these ranges are defined automatically by the transcoder, but for some types of transcoders it makes sense to set them manually.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_qp_range"
              }
            ]
          },
          "threads": {
            "description": "Number of threads used by the decoder when transcoding with CPU (it is not used for other types of transcoder).\nThis parameter allows to increase performance by adding new threads. By default, it is autodetected.\n",
            "nullable": true,
            "type": "integer"
          },
          "open_gop": {
            "description": "Whether open GOP is used. Open GOP contains P-frames that refer to the frames before the keyframe.\nIt allows to decrease bitrate to 5-7%, but can result in breaking the picture.\n",
            "default": false,
            "type": "boolean"
          },
          "interlace": {
            "description": "This parameter is used to get an interlaced stream from a progressive one.\nThe allowed values are `true` (interlaced video), `false` (progressive video), or one of the methods for producing interlaced video supported for the selected type of transcoder.\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/interlace_settings"
              }
            ]
          },
          "rc_method": {
            "description": "A method for creating output video with constant bitrate suitable for broadcasting to television networks.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            },
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/rc_method"
              }
            ]
          },
          "temporal_tradeoff": {
            "description": "Drop some frames in dynamic scenes when the transcoder does not have time to code all frames.\nThe allowed values are: \n\n* `15` - drop 1 from 5\n* `13` - drop 1 from 3\n* `12` - drop 1 from 2\n* `23` - drop 2 from 3\n* `0` - do not drop frames\n",
            "nullable": true,
            "type": "integer"
          },
          "vbv_bufsize": {
            "description": "Virtual buffer size, it bits. The default value is `gop / fps * bitrate`.\n",
            "nullable": true,
            "type": "integer"
          },
          "resize_mode": {
            "description": "The mode to be used for resizing video tracks. It is one of the computing platforms for Flussonic Coder:\n\n* vic -  Video Image Converter, specific for Jetson Nvidia\n* cuda - CUDA (or Compute Unified Device Architecture)\n",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_resize_mode"
              }
            ]
          },
          "burn": {
            "description": "Configuration of burn-in text, timestamp, or subtitles to video frames.",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_burn"
              }
            ]
          },
          "extra": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true,
            "description": "Some additional options."
          }
        },
        "required": [
          "track"
        ]
      },
      "transcoder_opts": {
        "type": "object",
        "properties": {
          "global": {
            "description": "Transcoder settings to be used for transcoding. \n",
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_global"
              }
            ],
            "x-default": {
              "$ref": "#/components/schemas/tc_global"
            }
          },
          "decoder": {
            "description": "Decoder settings to be used for transcoding. \n",
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_decoder"
              }
            ],
            "x-default": {
              "$ref": "#/components/schemas/tc_decoder"
            }
          },
          "audio": {
            "description": "List of audio tracks the stream audio track will be transcoded into.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/tc_audio_opts"
              }
            ],
            "x-default": {
              "$ref": "#/components/schemas/tc_audio_opts"
            },
            "deprecated": true
          },
          "video": {
            "description": "List of video tracks the stream video track will be transcoded into. \n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/tc_video_opts"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "tracks": {
            "description": "Info on the tracks.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transcoder_track_info"
                }
              ]
            },
            "type": "array",
            "default": []
          }
        }
      },
      "dvr_schedule_range": {
        "items": {
          "type": "integer"
        },
        "type": "array"
      },
      "dvr_range": {
        "type": "object",
        "properties": {
          "from": {
            "description": "The beginning of the recorded DVR range. \n",
            "type": "integer",
            "format": "utc",
            "example": 1525186456
          },
          "duration": {
            "description": "The duration of the recorded DVR range. \n",
            "type": "integer",
            "format": "seconds",
            "example": 28800
          }
        },
        "required": [
          "from",
          "duration"
        ]
      },
      "dvr_motion_event": {
        "type": "object",
        "properties": {}
      },
      "dvr_base_config": {
        "type": "object",
        "properties": {
          "storage_limit": {
            "description": "Maximum disk consumption in bytes. When this limit is reached, \nthe oldest segment of the recording will be overridden by later data.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 400000000000
          },
          "disk_space": {
            "description": "Maximum disk consumption in bytes. (Alias for `storage_limit`.)",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "deprecated": true,
            "x-alias": "storage_limit"
          },
          "disk_usage_limit": {
            "description": "Maximum disk consumption in percents. When this limit is reached, \nthe oldest segment of the recording will be overridden by later data.\n",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "example": 98
          },
          "disk_limit": {
            "description": "Maximum disk consumption in percents. (Alias for `disk_usage_limit`.)",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "deprecated": true,
            "x-alias": "disk_usage_limit"
          },
          "expiration": {
            "description": "Archive depth - a period (in seconds) back from the current moment during which the archive is stored. \nAs time goes, the parts of the recording which are older than the archive depth are being overridden by the later parts.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "examples": {
              "default": {
                "value": 604800
              },
              "mylive/bunny": {
                "value": 0
              }
            }
          },
          "dvr_limit": {
            "description": "Archive depth - a period (in seconds) back from the current moment during which the archive is stored. \n(Alias for `expiration`.)\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "deprecated": true,
            "x-alias": "expiration"
          },
          "dvr_replicate": {
            "description": "Whether DVR replication is used. Replication means that a DVR archive is stored on two (or more) Flussonic servers.\nIt can be used for reliability or for broadcasting with a time shift. More information can be found [here](https://flussonic.com/doc/digital-video-recording-dvr/dvr-replication/).\n",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "replication_port": {
            "description": "Replication port. \nBy default, replication is enabled on the port specified when configuring the M4F source. \nYou can specify a separate port for replication.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/network_port"
              }
            ],
            "nullable": true,
            "example": 8002
          },
          "schedule": {
            "description": "One or several time intervals for recording by schedule.\nThe beginning and the end of each interval are set in \"hhmm\" format (without leading zeros ) according to UTC standard. \nFor example, `2330` is for 23:30, `800` - for 08:00. The interval can go over midnight, e.g. 22:00-1:30. In this case it is set as follows: `[2200,130]`.\n\nScheduled recording can be useful for the channels with part-time broadcasting. \nIt allows to save disk space significantly.\n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_schedule_range"
                }
              ]
            },
            "type": "array",
            "nullable": true,
            "example": [
              [
                800,
                1600
              ],
              [
                2200,
                130
              ]
            ]
          },
          "dvr_offline": {
            "description": "If this option is enabled, Flussonic detects DVR at the start of the stream,\nbut does not start recording immediately and waits for external API request.\n",
            "type": "boolean",
            "nullable": true
          },
          "copy": {
            "description": "The URL of another storage to copy the blobs (hours of the archive) into. \nCopying is done when a blob is complete (i.e., once an hour), and therefore helps significantly reduce the number of network requests to a cloud storage.\n",
            "type": "string",
            "format": "dvr_url",
            "nullable": true,
            "example": "s3://token@minio.mycompany.com/dvr-bucket"
          },
          "keep_locks": {
            "description": "Whether the locked DVR recordings will be kept when disk usage limit is reached (in bytes or percents).\n",
            "type": "boolean",
            "nullable": true,
            "example": false
          }
        }
      },
      "dvr_storage_config": {
        "type": "object",
        "properties": {
          "name": {
            "description": "DVR configuration name.",
            "type": "string",
            "format": "dvr_name",
            "x-primary-key": true
          },
          "root": {
            "description": "A path where the DVR archive is stored.",
            "type": "string",
            "format": "dvr_url"
          },
          "raid": {
            "description": "This value is present if RAID (redundant array of independent disks) is enabled. More information can be found [here](https://flussonic.com/doc/digital-video-recording-dvr/flussonic-raid-for-dvr/). \nThe allowed value is 0.\n",
            "type": "integer",
            "nullable": true
          },
          "check_mount": {
            "description": "If this parameter is set to 'true' (by default), \nFlussonic will check if the disks were mounted properly before writing to them.\n",
            "type": "boolean",
            "nullable": true
          },
          "active": {
            "description": "The number of disks to write the archive.",
            "type": "integer",
            "nullable": true
          },
          "index": {
            "description": "A directory on an SSD disk where the data will be cached.",
            "type": "string",
            "format": "disk_path",
            "nullable": true
          },
          "disks": {
            "description": "RAID disks mounted on the server.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/raid_disk_config"
            },
            "nullable": true
          }
        },
        "required": [
          "name",
          "root"
        ]
      },
      "dvr_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/dvr_storage_config"
          },
          {
            "$ref": "#/components/schemas/dvr_base_config"
          }
        ]
      },
      "raid_disk_config": {
        "type": "object",
        "properties": {
          "path": {
            "description": "The path to a mounted disk. \n",
            "example": "volume1",
            "type": "string",
            "format": "disk_path",
            "x-primary-key": true
          },
          "mode": {
            "description": "The mode of using the disk. Read more about the modes [here](https://flussonic.com/doc/digital-video-recording-dvr/flussonic-raid-for-dvr/#raid-configuration-example-with-the-full-set-of-options).\n",
            "example": "keep",
            "allOf": [
              {
                "$ref": "#/components/schemas/raid_disk_mode"
              }
            ],
            "nullable": true
          },
          "stats": {
            "description": "The runtime statistics about RAID. The statistics shows the state of disks.\nMore information can be found [here](https://flussonic.com/doc/digital-video-recording-dvr/flussonic-raid-for-dvr/#reading-runtime-statistics)\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/raid_disk_stats"
              }
            ],
            "nullable": true
          }
        }
      },
      "raid_disk_mode": {
        "type": "string",
        "enum": [
          "normal",
          "migrate",
          "readonly",
          "rescue",
          "abandon",
          "keep"
        ]
      },
      "raid_disk_stats": {
        "type": "object",
        "properties": {
          "disk": {
            "description": "The path to a mounted disk. \n",
            "example": "volume1",
            "type": "string",
            "format": "disk_path",
            "nullable": true
          },
          "path": {
            "description": "A path where the DVR archive is stored.",
            "type": "string",
            "format": "dvr_url",
            "nullable": true
          },
          "mounted": {
            "description": "Whether the disk is mounted correctly.",
            "type": "boolean",
            "nullable": true
          },
          "mode": {
            "description": "The mode of using the disk. Read more about the modes [here](https://flussonic.com/doc/digital-video-recording-dvr/flussonic-raid-for-dvr/#raid-configuration-example-with-the-full-set-of-options).\n",
            "example": "keep",
            "allOf": [
              {
                "$ref": "#/components/schemas/raid_disk_mode"
              }
            ],
            "nullable": true
          },
          "blobs_count": {
            "description": "The number of blobs on the disk.",
            "type": "integer",
            "nullable": true
          },
          "size": {
            "description": "The size of the disk in bytes.",
            "type": "integer",
            "format": "bytes",
            "nullable": true
          },
          "usage": {
            "description": "Disk utilization percentage.",
            "type": "integer",
            "format": "percents",
            "nullable": true
          },
          "io_usage": {
            "description": "Disk I/O utilization percentage from `/proc/devstat`.",
            "type": "integer",
            "format": "percents",
            "nullable": true
          },
          "migration_speed": {
            "description": "The speed of copying the last blob, in bytes per second.",
            "type": "integer",
            "format": "speed",
            "nullable": true
          },
          "migration_eta": {
            "description": "The estimated migration end time, in UTC seconds.",
            "type": "integer",
            "format": "utc",
            "nullable": true
          },
          "migration_updated": {
            "description": "The time when the values of `migration_speed` and `migration_eta` were last updated.",
            "type": "integer",
            "format": "utc",
            "nullable": true
          }
        }
      },
      "record_input_spec": {
        "type": "object",
        "properties": {
          "root": {
            "description": "The path to the directory where the source will be recorded.\n\nThis parameter is related to the `record_unput` feature that allows recording the stream input as-is. \nRecommended for debugging needs **only**.\n",
            "type": "string",
            "format": "dvr_url",
            "nullable": true
          },
          "storage_limit": {
            "description": "Maximum disk consumption in bytes. When this limit is reached, \nthe oldest segment of the recording will be overridden by later data.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 400000000000
          },
          "expiration": {
            "description": "A period (in seconds) back from the current moment during which the files are stored.\nAs time goes, the files which are older than this period are being overridden by the later files.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "example": 604800
          },
          "disk_space": {
            "description": "Maximum disk consumption in bytes. \nWhen this limit is reached, the oldest files will be overridden by later files.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "deprecated": true,
            "x-alias": "storage_limit"
          },
          "dvr_limit": {
            "description": "A period (in seconds) back from the current moment during which the files are stored.\nAs time goes, the files which are older than this period are being overridden by the later files.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "deprecated": true,
            "x-alias": "expiration"
          }
        }
      },
      "cache_spec": {
        "type": "object",
        "properties": {
          "path": {
            "description": "The path where the files from the cloud or HTTP are cached to speed up broadcasting.",
            "type": "string",
            "format": "disk_path",
            "nullable": true,
            "example": "/storage/cache"
          },
          "reference": {
            "description": "The name of the cache.",
            "type": "string",
            "format": "cache_name",
            "nullable": true,
            "example": "cache1"
          },
          "misses": {
            "description": "The number of requests necessary for a file to be cached.",
            "type": "integer",
            "nullable": true,
            "example": 3
          },
          "storage_limit": {
            "description": "Maximum disk consumption in bytes. \nWhen this limit is reached, the oldest files will be overridden by later files.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 400000
          },
          "expiration": {
            "description": "A period (in seconds) back from the current moment during which the files are stored.\nAs time goes, the files which are older than this period are being overridden by the later files.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "example": 3600
          },
          "disk_limit": {
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "deprecated": true,
            "x-alias": "storage_limit",
            "description": "Maximum disk consumption. Replaced by `storage_limit` in newer versions."
          },
          "time_limit": {
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "deprecated": true,
            "x-alias": "expiration",
            "description": "Segment expiration period. Replaced by `expiration` in newer versions."
          }
        }
      },
      "vbi_line": {
        "anyOf": [
          {
            "maximum": 23,
            "minimum": 6,
            "type": "integer"
          },
          {
            "maximum": 335,
            "minimum": 318,
            "type": "integer"
          }
        ]
      },
      "ttxt_descriptors": {
        "properties": {
          "page": {
            "description": "Page number of the teletext received from an SDI card.\nIt is defined according to ETS 300 706 teletext specification.\n\nThe information about the pages is received from the stream provider.\n",
            "type": "integer",
            "x-primary-key": true,
            "example": 100
          },
          "type": {
            "description": "Teletext page type defined according to the Specification for Service Information (SI) in DVB systems, 6.2.32 Teletext descriptor in EN 300 468 Digital Video Broadcasting (DVB).",
            "enum": [
              "initial",
              "subtitle",
              "impaired"
            ],
            "type": "string",
            "example": "initial"
          }
        },
        "required": [
          "page",
          "lang",
          "type"
        ],
        "type": "object"
      },
      "vbi_service": {
        "enum": [
          "ttxt"
        ],
        "type": "string"
      },
      "srt_config": {
        "type": "object",
        "properties": {
          "port": {
            "description": "Listening port or a `host:port` pair for the SRT configuration.\nMust be unique on the whole server.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "example": 9050
          },
          "minversion": {
            "description": "The minimum SRT version that is required from the peer for SRT publication.\nThe format is `x.y.z`. \nThe default value is `1.0.0`.\n",
            "type": "string",
            "nullable": true,
            "x-notice": "SRTO_MINVERSION (0x010000)",
            "example": "1.1.0"
          },
          "version": {
            "description": "Required SRT version. The format is `x.y.z`.\nThe default value is `1.0.0`.\n",
            "type": "string",
            "nullable": true,
            "x-notice": "SRTO_VERSION",
            "example": "1.3.0"
          },
          "enforcedencryption": {
            "description": "Whether both connection parties must have the same password set (including empty, in other words, with no encryption). \nIf the passwords do not match or only one side is unencrypted, the connection is rejected. \nThe default value is `true`.\n",
            "type": "boolean",
            "nullable": true,
            "x-notice": "SRTO_ENFORCEDENCRYPTION (true)",
            "example": true
          },
          "passphrase": {
            "description": "The password for the encrypted transmission. \nIts length should be not less than 10 and not more than 79 characters. \nThe default value is an empty string (\"\").\n",
            "type": "string",
            "nullable": true,
            "x-notice": "SRTO_PASSPHRASE (\"\")",
            "example": "mytopsecret"
          },
          "timeout": {
            "description": "Data transmission timeout in seconds. \nIf set to `false` then data transmission time is unlimited. This is a defalut behavior.\n",
            "anyOf": [
              {
                "type": "integer",
                "format": "seconds"
              },
              {
                "enum": [
                  false
                ],
                "type": "boolean"
              }
            ],
            "nullable": true,
            "x-notice": "SRTO_RCVTIMEO SRTO_SNDTIMEO (ms, -1 no limit)",
            "example": 10
          },
          "linger": {
            "description": "The time, in seconds, that the socket waits for the unsent data before closing. \nThe default value is 180.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "x-notice": "SRTO_LINGER on, (180s) (off - 0s)",
            "example": 15
          }
        }
      },
      "mpegts_lang_track": {
        "anyOf": [
          {
            "enum": [
              "default"
            ],
            "type": "string"
          },
          {
            "type": "string"
          }
        ]
      },
      "stream_dvr_specific_spec": {
        "type": "object",
        "properties": {
          "reference": {
            "description": "Stream can refer to the globally declared DVR. This option referres to a single DVR entry.",
            "type": "string",
            "format": "dvr_name",
            "nullable": true,
            "example": "localdvr0"
          },
          "root": {
            "description": "If no `reference` specified, then `root` must be specified. Video recording will be made to `root/name` directory.",
            "type": "string",
            "format": "dvr_url",
            "nullable": true,
            "examples": {
              "mylive/bunny": {
                "value": ""
              },
              "default": {
                "value": "/storage"
              }
            }
          }
        }
      },
      "stream_dvr_spec": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_dvr_specific_spec"
          },
          {
            "$ref": "#/components/schemas/dvr_base_config"
          }
        ]
      },
      "transponder_pid": {
        "type": "object",
        "properties": {
          "pid": {
            "description": "This parameter sets PID to specify which track to include into output MPTS stream. \nTransponder will include only the tracks with specified PIDs.\n\nIt is possible to set PID values for video and audio tracks, as well as for PMT and SDT.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/video-playback/udp-multicast-with-constant-bitrate/#creating-an-output-mpts-stream"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ],
            "x-primary-key": true
          },
          "content": {
            "description": "Content of the track.",
            "enum": [
              "system",
              "video",
              "audio",
              "text",
              "application",
              "metadata"
            ],
            "type": "string",
            "example": "audio"
          },
          "track": {
            "description": "Number of the track set by Flussonic (usually, all video tracks and then all audio tracks are numbered starting from 1).\n",
            "type": "integer",
            "example": 1
          },
          "bitrate": {
            "description": "Bitrate of the track.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "example": 2543
          }
        },
        "required": [
          "pid",
          "content",
          "track"
        ]
      },
      "vision_spec": {
        "type": "object",
        "properties": {
          "gpu": {
            "description": "The number of a video card where video analytic is performed, starts from 0.\n",
            "type": "integer",
            "nullable": true,
            "example": 1
          },
          "alg": {
            "description": "The algorithm used for video analytics.\n",
            "type": "string",
            "oneOf": [
              {
                "const": "faces",
                "description": "The algorithm for face recognition is used."
              },
              {
                "const": "plates",
                "description": "The algorithm for license plate recognition is used (the default value)."
              },
              {
                "const": "fake_detector",
                "description": "The algorithm used only for tests, it produces an event each frame processed."
              }
            ],
            "nullable": true,
            "example": "faces"
          },
          "areas": {
            "description": "This parameter allows you to select specific polygonal area(s) to detect license plates (works only for `alg = plates`).\nBy default, it is empty and the recognition system searches for license plates over all the camera field of view.\n\nEach area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.\nThe vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.\n",
            "type": "string",
            "nullable": true
          }
        }
      },
      "auth_spec": {
        "type": "object",
        "properties": {
          "url": {
            "description": "The URL of an HTTP backend.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_url"
              }
            ],
            "nullable": true,
            "example": "http://middleware-address/auth/v2"
          },
          "domains": {
            "description": "Specifying the domains, within which playing this video is allowed. \nThis does not work for those clients that do not pass the value of Referer HTTP header.\n",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true,
            "example": [
              "mycompany.com"
            ]
          },
          "max_sessions": {
            "description": "The maximal number of streams or files the user can view simultaneously.\nThis limitation allows to prevent users from full restreaming to their servers.\n",
            "type": "integer",
            "nullable": true,
            "example": 5000
          },
          "allowed_countries": {
            "description": "Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks. \n\nFlussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses. \nNew releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated. \nTherefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/geoip/"
            },
            "items": {
              "type": "string",
              "format": "iso3166"
            },
            "type": "array",
            "nullable": true,
            "example": [
              "US",
              "DE",
              "GB"
            ]
          },
          "disallowed_countries": {
            "description": "Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content. \n\nFlussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses. \nNew releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated. \nTherefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/geoip/"
            },
            "items": {
              "type": "string",
              "format": "iso3166"
            },
            "type": "array",
            "nullable": true,
            "example": [
              "US",
              "DE",
              "GB"
            ]
          },
          "soft_limitation": {
            "description": "If this option is enabled and `max_sessions` limitation is used, the extra sessions are interrupted not immediately, but in 30 or 90 seconds.\nThis can be useful for middlewares that cannot generate a new token for every new stream or file request \nand therefore need time to understand that all sessions are being used.\n",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "session_keys": {
            "description": "A list of keys to generate a session ID value, allowing to configure the authorization scheme \nwhich is a hash sum calculated as follows: `hash(name + ip + proto)`.\nThis parameter allows to finish one session and start another one with the same authorization token.\nThe keys `name`,`ip`, and `proto` are required.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/#how-to-finish-one-session-and-start-another-one-with-the-same-token"
            },
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/session_key"
                }
              ]
            },
            "type": "array",
            "nullable": true,
            "example": [
              "name",
              "token",
              "proto",
              "ip"
            ]
          },
          "extra": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true,
            "description": "Some additional options."
          }
        }
      },
      "stream_stats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_stats_base"
          },
          {
            "$ref": "#/components/schemas/cloud_resources"
          }
        ]
      },
      "stream_stats_base": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Runtime stream ID.",
            "example": "61893ba6-07b3-431b-b2f7-716ac1643953"
          },
          "source_id": {
            "type": "string",
            "format": "uuid",
            "description": "Current source ID.",
            "example": "61893be1-054e-4acc-8d24-8ed92efe6ad0"
          },
          "opened_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when the stream opened before authorization/connection completed(in UTC milliseconds).",
            "example": 1636383729002
          },
          "started_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when the stream started after authorization/connection completed(in UTC milliseconds).",
            "example": 1636383729002
          },
          "status": {
            "description": "Indicates the status of the stream.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_status"
              }
            ]
          },
          "backup_running": {
            "description": "Whether a backup is currently running.",
            "type": "boolean"
          },
          "dvr_enabled": {
            "description": "If DVR is enabled for the stream.",
            "default": true,
            "type": "boolean"
          },
          "dvr_info": {
            "description": "The information about the recorded DVR archive.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvr_info"
              }
            ],
            "nullable": true,
            "examples": {
              "mylive/bunny": {
                "value": ""
              }
            }
          },
          "dvr_replication": {
            "description": "If DVR replication is enabled for the stream.\nReplication means that a DVR archive is stored on two (or more) Flussonic servers for reliability.\n",
            "type": "integer",
            "format": "percents"
          },
          "dvr_replication_running": {
            "description": "If DVR replication is in progress for the stream.\nReplication means that a DVR archive is stored on two (or more) Flussonic servers for reliability.\n",
            "default": false,
            "type": "boolean"
          },
          "last_dts": {
            "type": "number",
            "format": "ticks",
            "description": "Last frame timestamp read from the stream.",
            "nullable": true,
            "example": 383835646
          },
          "last_dts_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "The time when the last time frame was sent to the stream output (in UTC).",
            "nullable": true,
            "example": 1636383841974
          },
          "media_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ],
            "description": "Technical information about the output media content.",
            "nullable": true
          },
          "alive": {
            "default": false,
            "type": "boolean",
            "nullable": true,
            "example": true,
            "description": "Becomes `false` when `ts_delay` > 12000 (= 12 seconds)"
          },
          "ts_delay": {
            "type": "number",
            "format": "ticks",
            "nullable": true,
            "example": 1284,
            "description": "The time period during which no frames were received from the stream's input."
          },
          "remote": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "x-notice": "Used only for grouping the streams in UI.",
            "description": "If the stream is not local, i.e. sourced from the remote server."
          },
          "source_hostname": {
            "type": "string",
            "format": "server_name",
            "deprecated": true,
            "x-notice": "Used only for grouping the streams in UI.",
            "description": "URL of the stream source."
          },
          "published_from": {
            "type": "string",
            "deprecated": true,
            "description": "IP address of the source of publication to Flussonic.",
            "example": "192.168.0.100"
          },
          "published_via": {
            "type": "string",
            "deprecated": true,
            "description": "The protocol used for publication to Flussonic.",
            "example": "rtmp"
          },
          "url": {
            "type": "string",
            "format": "url",
            "deprecated": true,
            "description": "The stream URL.",
            "examples": {
              "default": {
                "value": "udp://239.0.0.1:1234"
              },
              "mylive/bunny": {
                "value": "publish://"
              }
            }
          },
          "source_error": {
            "type": "string",
            "deprecated": true,
            "examples": {
              "default": {
                "value": "frame_drop"
              },
              "mylive/bunny": {
                "value": ""
              }
            },
            "description": "Error code showing if there are any problems with capturing the stream."
          },
          "input_error_rate": {
            "type": "integer",
            "description": "The number of packets dropped per second.",
            "example": 0
          },
          "coder_error": {
            "default": false,
            "type": "boolean",
            "description": "Shows if there was any encoding error."
          },
          "lifetime": {
            "type": "number",
            "format": "milliseconds",
            "description": "The time period in seconds during which the stream is being captured.",
            "example": 71977
          },
          "retry_count": {
            "type": "integer",
            "description": "The number of attempts to restore the stream if `alive=false`.",
            "example": 0
          },
          "client_count": {
            "type": "integer",
            "format": "client_count",
            "description": "The number of clients receiving the stream.",
            "example": 3
          },
          "last_access_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "Date and time the stream was accessed the last time.",
            "example": 1669106270979
          },
          "bytes_in": {
            "type": "integer",
            "format": "bytes",
            "description": "The amount of stream data received from the input.",
            "example": 2445568
          },
          "bytes_out": {
            "type": "integer",
            "format": "bytes",
            "description": "The amount of stream data sent to the clients.",
            "example": 0
          },
          "out_bandwidth": {
            "type": "integer",
            "format": "speed",
            "description": "The output traffic of the stream.",
            "example": 0
          },
          "bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Stream bitrate.",
            "example": 186
          },
          "input_bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Input bitrate.",
            "example": 186
          },
          "output_bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Stream output bitrate.",
            "example": 186
          },
          "current_agent_id": {
            "type": "string",
            "format": "agent_id",
            "description": "The identifier of the Agent that is currently serving the stream."
          },
          "agent_status": {
            "enum": [
              "connected",
              "not_connected",
              "rproxy_not_configured"
            ],
            "type": "string",
            "description": "The status of the Agent serving the stream."
          },
          "running_transcoder": {
            "default": false,
            "type": "boolean",
            "description": "If the transcoder is enabled for the stream."
          },
          "transcoder_overloaded": {
            "default": false,
            "type": "boolean",
            "description": "If the transcoder is overloaded."
          },
          "running": {
            "default": true,
            "deprecated": true,
            "type": "boolean",
            "description": "Shows if the stream is ready to be served to clients. Replaced with `status = running` in newer versions.",
            "example": true
          },
          "start_running_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "Date and time when `status = running` was set."
          },
          "running_on": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "server_name"
            },
            "description": "List of servers hostnames where the stream is running on.",
            "example": [
              "streamer1.example.com"
            ]
          }
        }
      },
      "stream_status": {
        "type": "string",
        "oneOf": [
          {
            "title": "Running",
            "const": "running",
            "description": "Input is OK, stream is ready to be served to your audience."
          },
          {
            "title": "Waiting",
            "const": "waiting",
            "description": "Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client."
          },
          {
            "title": "Error",
            "const": "error",
            "description": "Something is wrong and Flussonic is not able to serve the stream to your audience."
          }
        ]
      },
      "pusher_status": {
        "anyOf": [
          {
            "enum": [
              "starting",
              "pending",
              "retry",
              "error"
            ],
            "type": "string"
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/session_status"
              }
            ]
          }
        ]
      },
      "play_protocols_spec": {
        "type": "object",
        "properties": {
          "whitelist": {
            "description": "- If set to `True`, server **allows** a playback only for listed protocols;\n- If set to `False`, server **forbids** a playback only for listed protocols;\n",
            "default": false,
            "type": "boolean"
          },
          "hls": {
            "description": "Whether to allow or deny an HLS stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "dash": {
            "description": "Whether to allow or deny a DASH stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "player": {
            "description": "Whether to allow or deny playback in embed.html, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "mss": {
            "description": "Whether to allow or deny an MSS stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "rtmp": {
            "description": "Whether to allow or deny an RTMP stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "rtsp": {
            "description": "Whether to allow or deny an RTSP stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "m4f": {
            "description": "Whether to allow or deny an M4F stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "m4s": {
            "description": "Whether to allow or deny an M4S stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "mseld": {
            "description": "Whether to allow or deny an MSE-LD stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "tshttp": {
            "description": "Whether to allow or deny an MPEG-TS stream playback over HTTP(S), depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "webrtc": {
            "description": "Whether to allow or deny an WebRTC stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "srt": {
            "description": "Whether to allow or deny an SRT stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "shoutcast": {
            "description": "Whether to allow or deny a SHOUTcast/Icecast stream playback, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "mp4": {
            "description": "Whether to allow or deny an MP4 file download over HTTP(S), depending on the `whitelist` properties.\nUsed to export DVR segment(s) in MP4 file.\n",
            "type": "boolean",
            "nullable": true
          },
          "jpeg": {
            "description": "Whether to allow or deny delivering JPEG thumbnails over HTTP(S), depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          },
          "api": {
            "description": "Whether to allow or deny API requests, depending on the `whitelist` properties.",
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "stream_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_config_specific"
          },
          {
            "$ref": "#/components/schemas/stream_config_base"
          },
          {
            "$ref": "#/components/schemas/stream_config_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_onpremises"
          },
          {
            "$ref": "#/components/schemas/stream_config_single_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_deprecated"
          },
          {
            "$ref": "#/components/schemas/stream_config_additional"
          }
        ]
      },
      "stream_config_stripped": {
        "description": "This is a reduced configuration of stream that contains only actual used config.\nCan compare it with stream_config that includes some runtime information and \ninterpretation of stream config information, like config_on_disk\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_config_specific"
          },
          {
            "$ref": "#/components/schemas/stream_config_base"
          },
          {
            "$ref": "#/components/schemas/stream_config_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_onpremises"
          },
          {
            "$ref": "#/components/schemas/stream_config_single_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_deprecated"
          }
        ]
      },
      "stream_config_specific": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "media_name",
            "description": "Globally unique stream name.",
            "x-primary-key": true,
            "examples": {
              "default": {
                "value": "hockey1"
              },
              "mylive/bunny": {
                "value": "mylive/bunny"
              }
            }
          },
          "title": {
            "description": "Human-readable title of the stream. Provided for SDT MPEG-TS table or\nSDP RTSP title parameter.\n",
            "type": "string",
            "example": "Hockey channel"
          },
          "position": {
            "type": "integer",
            "format": "sort_index",
            "description": "Position of the stream in order of streams in the config file, if declared.",
            "nullable": true,
            "example": 2
          },
          "named_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/named_by"
              }
            ],
            "description": "Where the stream is initialized: config, user play/publication, or remote\ncluster server.\n",
            "example": "config"
          },
          "template": {
            "description": "Template of the stream.",
            "type": "string",
            "format": "media_name",
            "example": "sports-hd"
          }
        },
        "required": [
          "name"
        ]
      },
      "stream_config_base": {
        "type": "object",
        "properties": {
          "static": {
            "default": true,
            "description": "Whether a stream is `static` or not. \nIf set to `True` the server will try to keep this stream running even if\nthere are no viewers or errors encountered.\n\nStreamer restarts *all* `static` streams even if any internal errors occur\nand the `static` streams crash.\n",
            "type": "boolean",
            "example": true
          },
          "disabled": {
            "description": "Whether a stream is disabled. Disabled streams are inactive and do not run. \nDisplayed only with the API calls.\n",
            "type": "boolean",
            "example": false
          },
          "inputs": {
            "description": "List of stream inputs. \n***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.\n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/stream_input"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "cluster_key": {
            "description": "Authorization key to fetch the streams from another streamer in a cluster. \nShould be configured for each `input`.\n",
            "type": "string",
            "deprecated": true,
            "x-delete-at": 22.02
          }
        }
      },
      "stream_config_media": {
        "type": "object",
        "properties": {
          "provider": {
            "description": "Human-readable name of the content provider. Used, for example, for MPEG-TS.      \n",
            "type": "string",
            "example": "SportsTV"
          },
          "clients_timeout": {
            "description": "Stream's lifetime after the last client was disconnected (can be expressed in *seconds* or set to `False`). \nApplicable to on-demand streams **only**.      \n",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "boolean"
              }
            ],
            "example": 485
          },
          "retry_limit": {
            "description": "Number of attempts for the server to reconnect to a data source.\nApplicable to on-demand streams **only**. If not defined, server will constantly try to reconnect (unlimited number of retries). \nIf the input does not become active after specified amount of attempts, stream shuts down till the next user request.\n",
            "type": "integer"
          },
          "groups": {
            "description": "List of groups the stream belongs to. Can be used for tagging,\nAPI calls, or configuration on restreamers.      \n",
            "items": {
              "type": "string",
              "format": "group_name"
            },
            "type": "array",
            "example": [
              "sporthd"
            ]
          },
          "source_timeout": {
            "description": "If a connected source does not send any data within this timeout period (in seconds), \nthe source connection is considered to be lost.\nThis is a default configuration for a stream, can be modified for any input.\n",
            "anyOf": [
              {
                "type": "integer",
                "format": "seconds"
              },
              {
                "enum": [
                  false
                ],
                "type": "boolean"
              }
            ],
            "example": 10
          },
          "backup": {
            "description": "When all inputs are down, this can be used to show at least something to users.\nIt is important to understand that backup video behaves differently, not as inputs. \nIt is not a _last input_ in the list. After any input stops sending frames, timer starts.\nAfter `source_timeout` seconds backup starts working, while all other inputs are still trying to\nconnect and start working.\nSo backup and all inputs are working in parallel.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/backup_config"
              }
            ]
          },
          "epg_enabled": {
            "description": "Whether to extract EPG from the input.",
            "type": "boolean",
            "example": true
          },
          "transcoder": {
            "description": "Configuration of the transcoder settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_opts"
              }
            ],
            "nullable": true,
            "examples": {
              "mylive/bunny": {
                "value": {}
              }
            }
          },
          "thumbnails": {
            "description": "Configuration of thumbnails generator.",
            "allOf": [
              {
                "$ref": "#/components/schemas/thumbnails_spec"
              }
            ]
          },
          "dvr": {
            "description": "DVR configuraton.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_dvr_spec"
              }
            ]
          },
          "auth": {
            "description": "Configuration of authorization backend (play sessions **only**).\nShould be replaced with an `on_play` configuration similar to `on_publish`.      \n",
            "externalDocs": {
              "description": "Find more information about `on_play` and `on_publish` here.",
              "url": "https://flussonic.com/doc/authorization/#enabling-playback-and-publish-sessions-authorization"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ],
            "deprecated": true,
            "x-delete-at": 23.02,
            "x-alias": "on_play"
          },
          "on_play": {
            "description": "Configuraton of authorization backend for play sessions.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ]
          },
          "on_publish": {
            "description": "Configuraton of authorization backend for publish sessions.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ]
          },
          "drm": {
            "description": "Configuraton of Digital Rights Management system (DRM).",
            "allOf": [
              {
                "$ref": "#/components/schemas/drm_spec"
              }
            ]
          },
          "protocols": {
            "description": "Configuration to allow/forbid playing the stream via various protocols. \n- If the `whitelist` option is set to 'true', the server allows a playback only for listed protocols;\n- If the `whitelist` option is set to 'false', the server forbids a playback for listed protocols;\n- Server allows a playback for all the protocols by default.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/play_protocols_spec"
              }
            ]
          },
          "prepush": {
            "description": "The time (in seconds) that *Flussonic* reserves for preloading the data, i. e. *buffering*.\nPrepush is always defined through GoP, but this option provides you with a more flexible way\nto configure the buffer size, e. g. a 1-3 or 7-10 seconds time interval.\n\nThe bigger the buffer size, the better the user experience is for the users\nwith a bad internet connection. However, the latency also increases.\n\nIf it is set to `False` to remove the latency, the stream's start time \nincreases. To decrease it, reduce the GoP size and make the bitrate larger \nor the video quality lower.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/glossary/#prepush"
            },
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "integer"
              }
            ],
            "example": false
          },
          "segment_count": {
            "description": "Number of segments stored in memory for the segment-based protocols, such as HLS and DASH.\nAdded to HLS live manifest. Do not forget that one more segment is stored for stale clients\nthat come too late, but the latest segment is not shown in the manifest.\n",
            "type": "integer",
            "example": 4
          },
          "segment_duration": {
            "description": "The time of the segment duration. Used for the protocols like HLS or DASH. \nThe disk config offers this value in seconds.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/segment_duration"
              }
            ],
            "example": 5000
          },
          "chunk_duration": {
            "description": "Chunk duration in LL-HLS manifest to be used for tunning latency.",
            "type": "integer",
            "format": "milliseconds",
            "example": 200
          },
          "url_prefix": {
            "description": "A string starting the addresses of separate segments within a *segment-based* playlists (HLS or DASH).\nEach sub-playlist is stored on Flussonic.\n\nIf set to `false`, the configured value in a template will be disabled. \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/#stream-and-group-settings"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/url_prefix"
              }
            ]
          },
          "hls_scte35": {
            "description": "Whether to enable SCTE-35 ad insertion markers signaling in HLS manifest.\nAd markers can be included in SCTE-35 (`scte35`), AWS (`aws`) formats or not included (`false`).      \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/iptv/ad-insertion-markers/#conversion-of-markers"
            },
            "anyOf": [
              {
                "enum": [
                  false
                ],
                "type": "boolean"
              },
              {
                "enum": [
                  "aws",
                  "scte35"
                ],
                "type": "string"
              }
            ],
            "example": "scte35"
          },
          "add_audio_only": {
            "description": "Whether to add an audio-only version of an HLS stream. \nUsed to create App Store compliant HLS streams to deliver the content to Apple iOS devices.      \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/#turning-on-audio-only-hls"
            },
            "type": "boolean",
            "example": true
          },
          "webrtc_abr": {
            "description": "WebRTC play configuration for a stream.",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_abr_opts"
              }
            ]
          },
          "pushes": {
            "description": "A list of pushes. When a server initiates the connection and sends a stream \nto other server(s), it is called a `push`.      \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/video-playback/pushing-a-stream-to-other-servers/"
            },
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/stream_push"
                }
              ]
            },
            "type": "array"
          },
          "mpegts_pids": {
            "description": "This parameter sets PIDs values for outgoing MPEG-TS streams. PID contains information about the TS package content and can be decoded according to special service tables. \nIt is possible to set PID values for PMT, SDT, video, and audio tracks. Tracks are numbered starting from one. \nThe code `a1=123` sets a PID value for the first audio track. It is possible to set the base index for the tracks of a certain type using the 0 (zero) index. \nFor example, `t0=100` sets PID=101 for the first track, 102 for the second, and so on. Numbers can be given in decimal form (by default) or hexadecimal with 16# prefix.       \n",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_mpegts_pids"
              }
            ]
          },
          "mpegts_ac3": {
            "description": "It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_mpegts_ac3"
              }
            ]
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "string",
            "description": "Stream labels in key value format",
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "playback_headers": {
            "description": "This parameter sets playback HTTP headers for streams.\n",
            "items": {
              "$ref": "#/components/schemas/playback_headers"
            },
            "type": "array"
          }
        }
      },
      "stream_config_onpremises": {
        "type": "object",
        "properties": {
          "record_input": {
            "description": "Configuration of recording the stream input as-is. Recommended for debugging needs **only**.",
            "allOf": [
              {
                "$ref": "#/components/schemas/record_input_spec"
              }
            ],
            "x-scope": [
              "flussonic"
            ]
          },
          "cluster_ingest": {
            "description": "Server configuration for a cluster ingest group.\nUsed to connect several servers between each other to capture the stream(s) and prevent the failover when one of the servers (peers) fails.\nMore information about the cluster ingest [here](https://flussonic.com/doc/cluster/video-ingest-in-a-cluster/#cluster-ingest-page).\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/cluster_ingest_config"
              }
            ],
            "x-scope": [
              "flussonic"
            ]
          },
          "cache": {
            "description": "Configuration of DVR cache.",
            "allOf": [
              {
                "$ref": "#/components/schemas/cache_spec"
              }
            ],
            "x-scope": [
              "flussonic"
            ]
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "description": "The param is deprecated and now used only for onvif_url and onvif_profile options.",
            "x-scope": [
              "flussonic",
              "central"
            ],
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "vision": {
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_spec"
              }
            ],
            "description": "Video analytics parameters.",
            "x-scope": [
              "flussonic"
            ]
          }
        }
      },
      "stream_config_single_media": {
        "type": "object",
        "properties": {
          "srt": {
            "description": "A port used for playing SRT streams. Can be set in global settings or for a particular stream. \nIf it is used in the configuration, Flussonic works as a \"Listener\" and receives connection requests from a source working as a \"Caller\".\nMore information [here](https://flussonic.com/doc/video-playback/#srt).\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "x-scope": [
              "flussonic"
            ],
            "example": 9060
          },
          "srt2": {
            "description": "A port used for playing SRT2 streams. Can be set in global settings or for a particular stream.\nIf it is used in the configuration, Flussonic works as a \"Listener\" and receives connection requests from a source working as a \"Caller\".\nMore information [here](https://flussonic.com/doc/video-playback/#srt).\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "x-scope": [
              "flussonic"
            ],
            "example": 9062
          },
          "srt_play": {
            "description": "SRT play configuration for a stream.",
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "x-scope": [
              "flussonic"
            ]
          },
          "srt2_play": {
            "description": "SRT2 play configuration for a stream.",
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "x-scope": [
              "flussonic"
            ]
          },
          "srt_publish": {
            "description": "SRT publishing configuration for a stream.",
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ]
          },
          "srt2_publish": {
            "description": "SRT2 publishing configuration for a stream.",
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ]
          }
        }
      },
      "stream_config_deprecated": {
        "type": "object",
        "properties": {
          "password": {
            "description": "Specify a password when publishing a password-protected stream.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/publishing-video-to-the-server/#authorization-for-stream-publishing"
            },
            "type": "string",
            "x-scope": [
              "flussonic"
            ]
          },
          "aac_ab": {
            "type": "integer",
            "description": "Bitrate of the AAC audio track.",
            "x-scope": [
              "flussonic"
            ]
          },
          "output_audio": {
            "allOf": [
              {
                "$ref": "#/components/schemas/output_audio"
              }
            ],
            "description": "Audio transcoding options.",
            "x-scope": [
              "flussonic"
            ]
          },
          "prefer_codec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_prefer_codec"
              }
            ],
            "description": "Preferred codec for WebRTC.",
            "x-scope": [
              "flussonic"
            ]
          },
          "transport": {
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_transport"
              }
            ],
            "description": "Transport protocol for WebRTC.",
            "x-scope": [
              "flussonic"
            ]
          },
          "max_bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Maximum bitrate for WebRTC.",
            "x-scope": [
              "flussonic"
            ]
          },
          "min_bitrate": {
            "type": "integer",
            "description": "Minimum bitrate for WebRTC.",
            "x-scope": [
              "flussonic"
            ]
          },
          "frames_timeout": {
            "type": "integer",
            "description": "Specifies the period of time, in seconds, \nfor which Flussonic Media Server waits for new frames to come from the data source \nbefore it generates the `frames_timed_out` event that informs you that the source might soon be lost. \nThis period of time must be smaller than `source_timeout`. \nIf frames come again from this source, before `source_timeout` has passed, Flussonic issues the `frames_restored` event.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_stepup": {
            "type": "integer",
            "description": "Increment step for raising the bitrate to the maximum, in percent. The default step is 30%. \nIf the loss is less than `abr_loss_lower`, \nFlussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_correction": {
            "type": "integer",
            "description": "The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.\nFlussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.\nThe default value is 300 kbit/s.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_loss_lower": {
            "type": "number",
            "description": "The lower limit of packet loss. When it is reached, Flussonic raises the bitrate. \nThat is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_loss_upper": {
            "type": "number",
            "description": "The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate. \nThat is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_stepdown": {
            "type": "number",
            "description": "A step of reducing the bitrate to the minimum. \nIf packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_mode": {
            "type": "integer",
            "description": "The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate. \nTwo options are possible:\n\n* `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.\n* `abr_mode=1` - This mode considers only packet losses and target bitrate.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_debug": {
            "type": "integer",
            "description": "Whether adaptive bitrate process is logged.",
            "x-scope": [
              "flussonic"
            ]
          },
          "abr_cycles": {
            "type": "integer",
            "description": "The number of cycles of bitrate auto-adjustment.\nAfter the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed. \nBy default, `abr_cycles`=5. \nIf `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.\n",
            "x-scope": [
              "flussonic"
            ]
          }
        }
      },
      "stream_config_additional": {
        "type": "object",
        "properties": {
          "config_on_disk": {
            "description": "Part of the effective config from the configuration file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_config_stripped"
              }
            ],
            "nullable": true
          },
          "config_override": {
            "description": "Part of the effective config overridden in runtime, e. g. `on_play`, `on_publish`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_config_stripped"
              }
            ],
            "nullable": true,
            "deprecated": true,
            "x-delete-at": 23.02
          },
          "stats": {
            "description": "Stream's metrics and other statistical information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_stats"
              }
            ],
            "readOnly": true
          }
        }
      },
      "template_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/template_config_specific"
          },
          {
            "$ref": "#/components/schemas/stream_config_base"
          },
          {
            "$ref": "#/components/schemas/stream_config_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_onpremises"
          },
          {
            "$ref": "#/components/schemas/stream_config_deprecated"
          }
        ]
      },
      "template_config_specific": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "media_name",
            "description": "Globally unique template name.",
            "x-primary-key": true
          },
          "prefixes": {
            "description": "List of prefixes that will be used to create dynamic names for published streams. \nA template creates one publishing point with one or more publishing locations, depending on the number of prefixes you define. \nAll settings within the template with prefixes apply to the streams published under the name of the prefixes. \nYou can also specify an empty prefix (`\"\"`) to publish a stream with any prefix or even without a prefix. \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/admin/stream-configuration-templates/#templates-and-prefixes"
            },
            "items": {
              "type": "string",
              "format": "media_name"
            },
            "type": "array",
            "nullable": true,
            "example": [
              "chats",
              ""
            ]
          }
        }
      },
      "push_stats": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Runtime pusher instance ID."
          },
          "opened_at": {
            "type": "integer",
            "format": "utc",
            "description": "The time when the pusher instance was created (in UTC)."
          },
          "bytes": {
            "type": "integer",
            "format": "bytes",
            "description": "Total amount of bytes sent since the pusher was created."
          },
          "status": {
            "description": "State of the push session.",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/api/streaming-sessions-in-flussonic/#events-and-session-states"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/pusher_status"
              }
            ]
          },
          "since": {
            "deprecated": true,
            "description": "The time, in UTC seconds, of the last error (is the pusher does not work) or of the pusher start (if it works).\n",
            "type": "integer",
            "format": "seconds"
          },
          "retries": {
            "description": "Number of retries since the last successful push.",
            "type": "integer"
          },
          "last_error": {
            "description": "If the pusher does not work, this field displays the text of the last error.",
            "type": "string",
            "deprecated": true
          },
          "sent_bytes": {
            "description": "Total amount of bytes sent since the pusher was created.",
            "type": "integer",
            "format": "bytes",
            "deprecated": true,
            "x-delete-at": 23.02,
            "x-alias": "bytes"
          }
        }
      },
      "vbi_lines": {
        "type": "object",
        "properties": {
          "service": {
            "description": "The service information passed to VBI of the output analog stream.\nThe allowed value is `ttxt` - teletext.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/vbi_service"
              }
            ],
            "nullable": true
          },
          "lines": {
            "description": "Numbers of VBI lines that will carry a teletext track.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/vbi_line"
                }
              ]
            },
            "type": "array",
            "nullable": true
          }
        }
      },
      "scale_algorithm": {
        "enum": [
          "fast_bilinear",
          "bilinear",
          "bicubic",
          "experimental",
          "neighbor",
          "area",
          "bicublin",
          "gauss",
          "sinc",
          "lanczos",
          "spline"
        ],
        "type": "string"
      },
      "web_logo_spec": {
        "type": "object",
        "properties": {
          "path": {
            "description": "Path to the logo file.\nIf specified without the `@` in the beginning, the logo will be served from the webroot (***not recommended***).\nIf specified with the `@` in the beginning, the logo will be served from the special directory and can be\nmanaged by the logo API.\n",
            "type": "string",
            "format": "logo_path",
            "nullable": true,
            "example": "@chan.png"
          },
          "height": {
            "description": "Set the specified height for the logo.",
            "type": "integer",
            "nullable": true,
            "example": 100
          },
          "width": {
            "description": "Set the specified width for the logo.",
            "type": "integer",
            "nullable": true,
            "example": 100
          },
          "left": {
            "description": "Change the position of the logo to the left.",
            "type": "integer",
            "nullable": true,
            "example": 15
          },
          "top": {
            "description": "Change the position of the logo to the top.",
            "type": "integer",
            "nullable": true,
            "example": 15
          },
          "right": {
            "description": "Change the position of the logo to the right.",
            "type": "integer",
            "nullable": true
          },
          "bottom": {
            "description": "Change the position of the logo to the bottom.",
            "type": "integer",
            "nullable": true
          }
        }
      },
      "network_port": {
        "maximum": 65535,
        "minimum": 0,
        "type": "integer"
      },
      "listen_spec": {
        "anyOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/network_port"
              }
            ]
          },
          {
            "type": "string",
            "format": "host_with_port"
          }
        ]
      },
      "listeners": {
        "type": "object",
        "properties": {
          "http": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_http_config"
                }
              ]
            },
            "default": [],
            "description": "List of HTTP ports or `host:port` pairs that will be used for listening.",
            "example": [
              80
            ]
          },
          "https": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_https_config"
                }
              ]
            },
            "default": [],
            "description": "List of HTTPS ports or `host:port` pairs that will be used for listening.",
            "example": [
              443
            ]
          },
          "rtmp": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                }
              ]
            },
            "description": "List of RTMP ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              1935
            ]
          },
          "rtmps": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_rtmps_config"
                }
              ]
            },
            "description": "List of RTMPS ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              1936
            ]
          },
          "rtsp": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                }
              ]
            },
            "description": "List of RTSP ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              554
            ]
          },
          "rtsps": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                },
                {
                  "$ref": "#/components/schemas/listen_ssl_config"
                }
              ]
            },
            "description": "List of RTSPS ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              555
            ]
          },
          "turn": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                }
              ]
            },
            "description": "List of TURN ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              3478
            ]
          },
          "snmp": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                }
              ]
            },
            "description": "List of SNMP ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              161
            ]
          },
          "sip": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_config"
                }
              ]
            },
            "description": "List of SIP ports or `host:port` pairs that will be used for listening.",
            "default": [],
            "example": [
              5060
            ]
          }
        }
      },
      "listen_config": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "format": "network_port",
            "description": "Port that will be used for listening.",
            "example": 80,
            "x-primary-key": true
          },
          "address": {
            "type": "string",
            "nullable": true,
            "description": "Network address that will be used for listening.",
            "example": "10.0.35.1"
          }
        },
        "required": [
          "port"
        ]
      },
      "listen_ssl_config": {
        "type": "object",
        "properties": {
          "ssl_protocols": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/tls_version"
                }
              ]
            },
            "nullable": true,
            "description": "List of SSL protocol versions that will be used for listening.",
            "example": [
              "tlsv1.1",
              "tlsv1.2"
            ]
          }
        }
      },
      "listen_http_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/listen_config"
          },
          {
            "type": "object",
            "properties": {
              "api": {
                "type": "boolean",
                "default": true,
                "description": "If false, listener do not serve api calls."
              }
            }
          }
        ]
      },
      "listen_https_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/listen_config"
          },
          {
            "type": "object",
            "properties": {
              "api": {
                "type": "boolean",
                "default": true,
                "description": "If false, listener do not serve api calls."
              }
            }
          },
          {
            "$ref": "#/components/schemas/listen_ssl_config"
          }
        ]
      },
      "listen_rtmps_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/listen_config"
          },
          {
            "$ref": "#/components/schemas/listen_ssl_config"
          }
        ]
      },
      "session_key_query": {
        "format": "query_session_key",
        "type": "string"
      },
      "input_stats": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Runtime input instance ID.",
            "example": "61fa2d68-75e4-433b-8c82-f2ce5444bf23"
          },
          "opened_at": {
            "type": "integer",
            "format": "utc",
            "description": "The time this input instance was created (in UTC seconds).",
            "example": 1643789953
          },
          "connected_at": {
            "description": "The time network connection was established (in UTC milliseconds).",
            "type": "number",
            "format": "utc_ms",
            "example": 1643789899794
          },
          "started_at": {
            "description": "The time the first frames appeared (in UTC milliseconds).",
            "type": "number",
            "format": "utc_ms",
            "example": 1643789899794
          },
          "ip": {
            "allOf": [
              {
                "$ref": "#/components/schemas/network_addr"
              }
            ],
            "description": "Peer's IP address.",
            "example": "192.168.0.100"
          },
          "bytes": {
            "type": "integer",
            "description": "Total amount of bytes sent since the input was created.",
            "example": 1698183
          },
          "error": {
            "type": "string",
            "description": "Information about the last source error.",
            "deprecated": true
          },
          "media_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ],
            "description": "Technical description of the input content."
          },
          "last_dts": {
            "type": "number",
            "format": "ticks",
            "description": "Last frame timestamp coming from this input.",
            "example": 1284
          },
          "last_dts_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "Last time a frame was processed from this input (in UTC).",
            "example": 1643789899794
          },
          "url": {
            "type": "string",
            "format": "url",
            "description": "Final URL after redirects.",
            "example": "udp://239.0.0.1:1234"
          },
          "active": {
            "description": "Whether this input is selected as active for the stream.",
            "type": "boolean",
            "example": true
          },
          "dvr_info": {
            "description": "Information about DVR stored on disk.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvr_info"
              }
            ]
          }
        }
      },
      "segment_duration": {
        "type": "integer",
        "format": "utc_ms",
        "minimum": 1000,
        "maximum": 15000
      },
      "stream_push": {
        "type": "object",
        "properties": {
          "url": {
            "description": "Target URL to push a video stream to.",
            "type": "string",
            "format": "push_url",
            "example": "rtmp://192.168.24.25/app1/stream2"
          },
          "stats": {
            "description": "Detailed runtime information about the push.",
            "allOf": [
              {
                "$ref": "#/components/schemas/push_stats"
              }
            ],
            "nullable": true
          },
          "multicast_loop": {
            "description": "Whether to capture multicast back to the *Flussonic* host. \nThis option allows you to ingest the sent stream on the sending host by *Flussonic* or other application.\nSet to `True` for a UDP MPEG-TS push.\n",
            "type": "boolean",
            "example": true
          },
          "vb": {
            "description": "Average bitrate per second that you can send of a video track, including all the headers and encapsulation in the transport stream. \nSo, for example, the value of vb=2720 approximately corresponds to the bitrate 2600 specified in the transcoder settings.\n",
            "type": "integer",
            "format": "speed",
            "example": 2720
          },
          "bitrate": {
            "description": "The bitrate of the whole stream.",
            "type": "integer",
            "format": "speed",
            "example": 3200
          },
          "pnr": {
            "description": "Program number in the outgoing MPEG-TS stream. A program may represent a television channel.\n",
            "type": "integer"
          },
          "pmt": {
            "description": "PID of Program Map Table (PMT) in the outgoing MPEG-TS stream.\n\nPMT contains the description of each program and lists the PIDs of elementary streams associated with that program.\nFor instance, a transport stream used in digital television might contain three programs, to represent three television channels. \nSuppose each channel consists of one video stream, one or two audio streams, and any necessary metadata. \nA receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program. \nIt can discard the contents of all other PIDs.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ]
          },
          "pids": {
            "description": "This parameter sets PIDs values for outgoing MPEG-TS streams. \nIt is possible to set PID values for PMT, STD and video and audio tracks.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_mpegts_pids"
              }
            ]
          },
          "mpegts_ac3": {
            "description": "It allows to specify pack information about ac3 for outgoing MPEGTS-TS streams. The default value is `system_b`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_mpegts_ac3"
              }
            ]
          },
          "dns": {
            "description": "Separate DNS server for a pusher.",
            "type": "string",
            "x-notice": "this is a bad designed push of Akamai",
            "deprecated": true,
            "x-delete-at": 23.02
          },
          "retry_limit": {
            "description": "The maximum number of times *Flussonic* retries to push the stream.",
            "type": "integer"
          },
          "retry_timeout": {
            "description": "How often *Flussonic* should retry attempts to send the stream, e.g., if it has become offline. \nIt is an interval in seconds, 5 seconds by default. \nYou can increase this value to reduce server load.\n",
            "type": "integer",
            "format": "seconds",
            "example": 7
          },
          "timeout": {
            "description": "Time interval, in seconds, after which the pusher is stopped if the source stream or publishing is stopped.\n",
            "type": "integer",
            "format": "seconds",
            "example": 10
          },
          "volume": {
            "description": "Audio volume coefficient.\nThe output audio volume is given by the relation: `output_volume = volume * input_volume`.\nThe maximum volume value is 1.0 (default value).\n",
            "type": "number",
            "nullable": true,
            "example": 0.5
          },
          "deinterlace": {
            "description": "Activate deinterlacing, i.e., converting an interlaced image to a progressive image. \nIt is necessary for comfortable viewing of legacy TV video on PC/mobile devices.\n",
            "type": "boolean"
          },
          "fps": {
            "deprecated": true,
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\nHigher frame rates capture more images per second, which makes for smoother video.\n\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames).\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/binary_value"
              }
            ]
          },
          "size": {
            "deprecated": true,
            "description": "The size of output frame in pixels.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/binary_value"
              }
            ],
            "example": "720x576"
          },
          "format": {
            "deprecated": true,
            "description": "The Decklink capture mode supported by a card. \nUsually a Decklink card supports a limited set of modes. \nEach mode is a combination of a frame size and FPS, encoded in Decklink format.\nFor example, `Hp50` is for 1920x1080 size with 50.00 FPS.\n\nYou can set this value manually or set size and FPS, and Flussonic will try to choose the appropriate format.\n",
            "anyOf": [
              {
                "$ref": "#/components/schemas/bm_display_mode"
              }
            ]
          },
          "video_format": {
            "description": "Specify SDI/HDMI output format",
            "anyOf": [
              {
                "$ref": "#/components/schemas/video_format"
              }
            ]
          },
          "vbi_lines": {
            "description": "Lines of VBI (vertical blanking interval) of an output analog stream that will contain teletext.\nIt is used for passing teletext from MPEG-TS to analog streams.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/passing-teletext-from-mpeg-ts-to-analog-streams/"
            },
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/vbi_lines"
                }
              ]
            },
            "type": "array"
          },
          "dthreads": {
            "description": "Defines a number of threads in a decoder. \nOne thread uses one core. \nThe default value equals 4, but you can set it equal to the number of cores of your CPU.\n",
            "type": "integer",
            "x-notice": "video decoder threads number"
          },
          "scale": {
            "description": "Defines a scaling algorithm.\nYou can choose only one algorithm at a time. \nIf a pushing stream has the same video resolution as an ingest stream, the `fast_bilinear` algorithm is used by default. \nIf a video resolution of a pushing stream does not equal the video resolution of an ingest stream, the bicubic algorithm is used by default. \nIf the algorithm is specified explicitly, it applies to all the formats.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/scale_algorithm"
              }
            ]
          },
          "disabled": {
            "description": "Disable pushing the stream.\n\nTemporary disabling, or pausing, an offline stream eliminates the necessity to remove it from the the configuration in order to stop Flussonic trying to push it. \nIn this way, the URL and other settings of a disabled stream remain in Flussonic.\n",
            "type": "boolean"
          },
          "minversion": {
            "description": "The minimum SRT version that is required from the peer for SRT publication.\nThe format is `x.y.z`. \nThe default value is `1.0.0`.\n",
            "type": "string",
            "example": "1.0.0"
          },
          "version": {
            "description": "Required SRT version. The format is `x.y.z`.\nThe default value is `1.0.0`.\n",
            "type": "string",
            "example": "1.3.0"
          },
          "enforcedencryption": {
            "description": "Whether both connection parties must have the same password set (including empty, in other words, with no encryption). \nIf the passwords do not match or only one side is unencrypted, the connection is rejected. \nThe default value is `true`.\n",
            "type": "boolean"
          },
          "passphrase": {
            "description": "The password for the encrypted transmission. \nIts length should be not less than 10 and not more than 79 characters. \nThe default value is an empty string (\"\").\n",
            "type": "string",
            "nullable": true,
            "example": "mytopsecret"
          },
          "connect_timeout": {
            "description": "Connection timeout, in seconds. Equals to 0 by default.",
            "type": "integer",
            "format": "seconds",
            "example": 2
          },
          "linger": {
            "description": "The time, in seconds, that the socket waits for the unsent data before closing. \nThe default value is 180.\n",
            "type": "integer",
            "format": "seconds",
            "example": 60
          },
          "latency": {
            "description": "Packet delivery delay. \nUsed to avoid bursts of missed packet retransmissions. The default value is 120.\n",
            "type": "integer",
            "format": "seconds",
            "example": 2
          },
          "streamid": {
            "description": "A string of maximum 512 characters set on the socket before the connection. \n\nThis string is a part of a callback that is sent by the caller and regisered by the listener. \nBased on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.\n\nIts format is `#!::` optionally followed by the parameters:\n* `r=` - stream name\n* `m=` - mode expected for connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).\n\nDuring SRT sessions between two Flussonic Media Services, the following parameters are automaticly added to `streamid`:\n* `s=` - the identifier of a session\n* `a=` - Flussonic verion\n",
            "type": "string",
            "example": "#!::r=my-stream,m=publish"
          },
          "standby": {
            "description": "Monitoring multicast group and stop pushing if another publisher presented",
            "type": "boolean"
          }
        },
        "required": [
          "url"
        ]
      },
      "stream_input": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_input_base"
          },
          {
            "$ref": "#/components/schemas/stream_input_deprecated"
          },
          {
            "$ref": "#/components/schemas/stream_input_fake"
          },
          {
            "$ref": "#/components/schemas/stream_input_file"
          },
          {
            "$ref": "#/components/schemas/stream_input_h323"
          },
          {
            "$ref": "#/components/schemas/stream_input_hls"
          },
          {
            "$ref": "#/components/schemas/stream_input_rtmp"
          },
          {
            "$ref": "#/components/schemas/stream_input_rtsp"
          },
          {
            "$ref": "#/components/schemas/stream_input_sdi"
          },
          {
            "$ref": "#/components/schemas/stream_input_srt"
          },
          {
            "$ref": "#/components/schemas/stream_input_tshttp"
          },
          {
            "$ref": "#/components/schemas/stream_input_webrtc"
          },
          {
            "$ref": "#/components/schemas/stream_input_mixer"
          },
          {
            "$ref": "#/components/schemas/stream_input_mosaic2"
          }
        ]
      },
      "stream_input_base": {
        "type": "object",
        "properties": {
          "url": {
            "description": "Unified URL to connect to the source and get the stream.\nHowever, not all protocols use URLs to describe the peer-to-peer connection.\n\nFor instance, WebRTC, SRT, and RTMP. \n\nWebRTC uses SDP (Session Description Protocol) to describe the negotiation between the peers.\n\nSRT requires IP and port, so we create an artificial URL to specify the options to manage the data interchange.\n\nRTMP uses a special URL consisting of at least two segments. *Flussonic* parses the URL and splits it into parts, \nusing the first segment as an RTMP application name.\n",
            "type": "string",
            "format": "input_url",
            "examples": {
              "default": {
                "value": "udp://239.0.0.1:1234"
              },
              "mylive/bunny": {
                "value": "publish://"
              }
            }
          },
          "source_timeout": {
            "description": "The period of time, in seconds, for which Flussonic will wait for new frames until it considers the source as lost.",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/live-streaming/source-failover/#source_timeout"
            },
            "anyOf": [
              {
                "type": "integer",
                "format": "seconds"
              },
              {
                "enum": [
                  false
                ],
                "type": "boolean"
              }
            ],
            "example": 20
          },
          "timeout": {
            "description": "The time, in seconds, for Flussonic to switch to the fallback source if the main source stops sending frames (video or audio). \nThe important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.\n",
            "type": "integer",
            "example": 10
          },
          "frames_timeout": {
            "description": "Specifies the period of time, in seconds, for which Flussonic Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost. \nThis period of time must be smaller than `source_timeout`. \nIf frames come again from this source, before `source_timeout` has passed, Flussonic issues the `frames_restored` event.\n",
            "type": "integer",
            "example": 3
          },
          "priority": {
            "description": "The priority that Flussonic takes into account when switching to another source.\nThe source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.\n\nBy default, the first source in the list has the highest priority and the last source in the list has the lowest priority. \nIf priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied. \n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/live-streaming/source-failover/#priority"
            },
            "type": "integer",
            "example": 1
          },
          "stats": {
            "description": "Detailed runtime information about the input.",
            "allOf": [
              {
                "$ref": "#/components/schemas/input_stats"
              }
            ],
            "readOnly": true
          },
          "user_agent": {
            "type": "string",
            "description": "User agent. Can be modified if a protocol allows it."
          },
          "cluster_key": {
            "type": "string",
            "description": "Authorization key used to fetch the stream from another streamer in a cluster.",
            "x-scope": [
              "flussonic"
            ]
          },
          "via": {
            "type": "string",
            "format": "agent_url",
            "description": "Agent ID. Used as a proxy to connect to the input server."
          },
          "max_bitrate": {
            "description": "Maximum bitrate value. *Flussonic* checks the input bitrate value, and if it overflows this value, the input will be disconnected.",
            "type": "integer",
            "format": "speed",
            "x-scope": [
              "flussonic",
              "cloud"
            ]
          },
          "remote_dvr": {
            "enum": [
              "nochain",
              "chain",
              "none"
            ],
            "type": "string",
            "description": "Mode to describe the interconnection with a DVR on a remote server.\nAllows to chain requests to other servers or read-only from a peer.\n",
            "x-scope": [
              "flussonic"
            ]
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "description": "An array of additional properties for customization of the request headers."
          },
          "no_clients_reconnect_delay": {
            "type": "integer",
            "description": "Skip input start if the stream has no clients."
          },
          "allow_if": {
            "type": "string",
            "description": "Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).\nThis option allows you to manage inputs without API requests.\n\nFor example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.\nThe `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.\nWhen you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.\n\nIf no such file, the input is allowed.\n"
          },
          "deny_if": {
            "type": "string",
            "description": "Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).\nThis option allows you to manage inputs without API requests.\n\nFor example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.\nThe `/path/to/file` file contains only the digit `1`. \nThat means that the first input will not be used when you play the stream, so the second one will.\nWhen you put `0` to the `/path/to/file` file, the first input is allowed to be played.\n\nIf no such file, the input is allowed.\n"
          }
        },
        "required": [
          "url"
        ]
      },
      "stream_input_deprecated": {
        "type": "object",
        "properties": {
          "aac": {
            "allOf": [
              {
                "$ref": "#/components/schemas/binary_boolean"
              }
            ],
            "x-notice": "used in rtsp_source instead of rtsp2",
            "description": "Enables transcoding to the AAC codec for the audio track of the input."
          }
        }
      },
      "stream_input_fake": {
        "type": "object",
        "properties": {
          "width": {
            "type": "integer",
            "description": "Width of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n"
          },
          "height": {
            "type": "integer",
            "description": "Height of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n"
          },
          "bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Bitrate of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n"
          }
        }
      },
      "stream_input_file": {
        "type": "object",
        "properties": {}
      },
      "stream_input_h323": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "H323 input ID."
          },
          "video_bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "H323 input bitrate."
          },
          "audio_bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "H323 audio bitrate."
          },
          "connections": {
            "type": "integer",
            "description": "H323 connections."
          }
        }
      },
      "stream_input_hls": {
        "type": "object",
        "properties": {
          "buffer": {
            "type": "integer",
            "deprecated": true,
            "x-delete-at": 23.03,
            "description": "HLS segments buffer. Forces to collect extra N segments first. Useful at bad connections, but increases the lag."
          },
          "skip_stalled_check": {
            "description": "By default Flussonic will wait for at least 2-3 new segments before making stream available.\n\nThis parameter allows to disable this protection. Use it at your own risk - with it enabled, old content might be repeated over and over.\n",
            "type": "boolean"
          },
          "ad": {
            "type": "boolean",
            "description": "Alias for `scte35`. Enables the ad injection.",
            "deprecated": true,
            "x-delete-at": 22.04
          }
        }
      },
      "stream_input_rtmp": {
        "type": "object",
        "properties": {
          "pageUrl": {
            "description": "URL of the web page from where the SWF file was loaded. \nThis is an RTMP header (Referer) used for establishing connection.\n",
            "type": "string",
            "format": "url",
            "example": "http://somehost/sample.html"
          },
          "swfUrl": {
            "description": "URL of the source SWF file making the connection by RTMP.",
            "type": "string",
            "format": "url",
            "example": "file://C:/FlvPlayer.swf"
          },
          "tcUrl": {
            "description": "URL of the remote Server for entering credentials. \nIt has the following format: `protocol://servername:port/appName/appInstance`.\n",
            "type": "string",
            "format": "url",
            "example": "rtmp://localhost:1935/testapp/instance1"
          }
        }
      },
      "stream_input_rtsp": {
        "type": "object",
        "properties": {
          "rtp": {
            "enum": [
              "udp"
            ],
            "type": "string",
            "description": "Whether to force UDP to capture a video from RTSP cameras."
          },
          "wait_rtcp": {
            "type": "boolean",
            "description": "Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.\n"
          }
        }
      },
      "stream_input_sdi": {
        "type": "object",
        "properties": {
          "mode": {
            "description": "Mode of the input stream captured from the Decklink card. It is composed of the size and FPS of the captured video. \n\nUsually, it is autodetected, but for some Decklink models that you'll need to specify it manually.\n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/live-streaming/decklink-sdi/#capturing-video-from-decklink-sdi-or-hdmi-cards"
            },
            "anyOf": [
              {
                "$ref": "#/components/schemas/bm_display_mode"
              }
            ],
            "example": "4d30"
          },
          "ainput": {
            "description": "Audio interface for capturing from the Decklink card.\n\nUsually, it is autodetected, but for some Decklink models you should specify it manually.\n",
            "anyOf": [
              {
                "type": "integer",
                "enum": [
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7
                ]
              },
              {
                "enum": [
                  "embedded",
                  "aes_ebu",
                  "analog",
                  "analog_xlr",
                  "analog_rca",
                  "microphone",
                  "headphones"
                ],
                "type": "string"
              }
            ],
            "example": "microphone"
          },
          "vinput": {
            "description": "Video interface for capturing from the Decklink card.\n\nUsually, it is autodetected, but for some Decklink models you should specify it manually.\n",
            "anyOf": [
              {
                "type": "integer",
                "enum": [
                  1,
                  2,
                  3,
                  4,
                  5,
                  6
                ]
              },
              {
                "enum": [
                  "sdi",
                  "hdmi",
                  "optical_sdi",
                  "component",
                  "composite",
                  "s_video"
                ],
                "type": "string"
              }
            ],
            "example": "hdmi"
          },
          "vpts": {
            "description": "Synchronization mode for video captured from the Decklink card.\n",
            "oneOf": [
              {
                "const": "audio",
                "description": "Synchronization by audio."
              },
              {
                "const": "ref",
                "description": "Synchronization according to the timing reference signal."
              },
              {
                "const": 2,
                "description": "Equivalent of 'audio'."
              },
              {
                "const": 3,
                "description": "Equivalent of 'ref'."
              }
            ]
          },
          "apts": {
            "description": "Synchronization mode for audio captured from the Decklink card.\n",
            "oneOf": [
              {
                "const": "video",
                "description": "Synchronization by video."
              },
              {
                "const": "ref",
                "description": "Synchronization according to the timing reference signal."
              },
              {
                "const": 1,
                "description": "Equivalent of 'video'."
              },
              {
                "const": 3,
                "description": "Equivalent of 'ref'."
              }
            ]
          },
          "pixel": {
            "description": "Preferred pixel format for captured video.",
            "oneOf": [
              {
                "const": "rgb8",
                "description": "rgb color model and 8 bits per pixel."
              },
              {
                "const": "rgb10",
                "description": "rgb color model and 10 bits per pixel."
              },
              {
                "const": "rgb12",
                "description": "rgb color model and 12 bits per pixel."
              },
              {
                "const": "yuv8",
                "description": "YUV color model and 8 bits per pixel."
              },
              {
                "const": "yuv10",
                "description": "YUV color model and 10 bits per pixel."
              },
              {
                "const": "8",
                "description": "equivalent of `yuv8`."
              },
              {
                "const": "10",
                "description": "equivalent of `yuv10`."
              }
            ]
          },
          "channel": {
            "description": "If an AJA SDI card has multiple output channels, specify the number of the channel to ingest video from.",
            "type": "integer",
            "example": 2
          },
          "sar": {
            "description": "The ratio of the width of the display representation to the width of the pixel representation of video.\n\nThis parameter is used for creating non-anamorphic video from anamorphic video.\n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder/#video-options"
            },
            "type": "string",
            "example": "16:9"
          },
          "audio_device": {
            "description": "The audio device to capture audio from Stream Labs SDI cards.\n\nThis parameter is specified for ALSA devices in the following format `interface:card,device`. \n",
            "type": "string",
            "example": "plughw:1,0"
          },
          "video_device": {
            "description": "The video device to capture video from Stream Labs SDI cards.\nIt is actually a path to a device file created on the disk by Video4Linux.\n",
            "type": "string",
            "example": "/dev/video0"
          },
          "vbi_device": {
            "description": "The VBI device to capture raw VBI data from Stream Labs SDI cards. VBI data can contain information about teletext or closed captions.\nIt is actually a path to a VBI device file created on the disk by Video4Linux.\n",
            "type": "string",
            "example": "/dev/vbi"
          },
          "ttxt_descriptors": {
            "description": "This information is necessary for adding into the PMT table to identify streams which carry teletext data in the resulting MPEG-TS stream.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ttxt_descriptors"
                }
              ]
            },
            "type": "array"
          },
          "vbi_threshold": {
            "description": "This parameter is used for debugging when reading teletext from VBI.\nThis is a threshold, in seconds, for turning on the decoder.\n",
            "type": "integer"
          },
          "vbi_debug": {
            "description": "This parameter allows logging the decoded data when reading teletext from VBI.",
            "type": "boolean"
          }
        }
      },
      "stream_input_srt": {
        "type": "object",
        "properties": {
          "minversion": {
            "description": "The minimum SRT version that is required from the peer for SRT publication.\nThe format is `x.y.z`. \nThe default value is `1.0.0`.\n",
            "type": "string",
            "example": "1.1.0"
          },
          "version": {
            "description": "Required SRT version. The format is `x.y.z`.\nThe default value is `1.0.0`.\n",
            "type": "string",
            "example": "1.3.0"
          },
          "enforcedencryption": {
            "description": "Whether both connection parties must have the same password set (including empty, in other words, with no encryption). \nIf the passwords do not match or only one side is unencrypted, the connection is rejected. \nThe default value is `true`.\n",
            "type": "boolean",
            "example": true
          },
          "passphrase": {
            "description": "The password for the encrypted transmission. \nIts length should be not less than 10 and not more than 79 characters. \nThe default value is an empty string (\"\").\n",
            "type": "string",
            "example": "9876543210"
          },
          "connect_timeout": {
            "description": "Connection timeout, in seconds. Equals to 0 by default.",
            "type": "integer",
            "example": 100
          },
          "linger": {
            "description": "The time, in seconds, that the socket waits for the unsent data before closing. \nThe default value is 180.\n",
            "type": "integer",
            "example": 60
          },
          "latency": {
            "description": "Packet delivery delay. \nUsed to avoid bursts of missed packet retransmissions. The default value is 120.\n",
            "type": "integer",
            "example": 100
          },
          "streamid": {
            "description": "A string of maximum 512 characters set on the socket before the connection. \n\nThis string is a part of a callback that is sent by the caller and regisered by the listener. \nBased on this information the listener can accept or reject the connection, select the desired data stream, or set an appropriate passphrase for the connection.\n\nIts format is `#!::` optionally followed by the parameters:\n* `r=` - stream name\n* `m=` - mode expected for the connection: `publish` (if the caller wants to send the stream data) or `request` (if the caller wants to receive the stream).\n* `password=` - a password for the authorization in a publish session (not recommended, better use `passphrase` option instead)\n\nDuring SRT sessions between two Flussonic Media Servers, the following parameters are automaticly added to streamid:\n* `s=` - the identifier of a session\n* `a=` - Flussonic version\n",
            "type": "string",
            "example": "#!::r=my-stream,m=publish"
          }
        }
      },
      "stream_input_tshttp": {
        "type": "object",
        "properties": {
          "programs": {
            "description": "Choose a program to ingest from an MPEG-TS stream.",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "example": [
              1
            ]
          },
          "pids": {
            "description": "Choose a specific PID to ingest from an MPEG-TS stream. \nPID identifies separate data stream inside the multiplexed MPEG-TS stream. \nIt is possible to set PID values for PMT, SDT, video, and audio tracks.\n",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "example": [
              211
            ]
          },
          "allow_subtitles": {
            "description": "Ingesting subtitles when capturing video from an MPEG-TS stream.\nThis option is now deprecated (replaced by `subtitles=accept`) and supported only for backward compatibility.\n",
            "deprecated": true,
            "x-delete-at": 23.02,
            "type": "boolean"
          },
          "subtitles": {
            "description": "This parameter allows to manage subtitles in an output stream.\n",
            "oneOf": [
              {
                "const": "drop",
                "description": "An output stream will have no subtitles track."
              },
              {
                "const": "accept",
                "description": "An output stream will have a subtitles track in DVB, without conversion to text (default behavior)."
              },
              {
                "const": "ocr_replace",
                "description": "An output stream will have a track containing subtitles converted to a text format (WebVTT)."
              },
              {
                "const": "ocr_add",
                "description": "An output stream will have two tracks containing subtitles: \nthe original track with subtitles in DVB and a new track with text subtitles.\n"
              }
            ],
            "example": "drop"
          },
          "closed_captions": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "string",
            "description": "The rules for handling the closed captions.\n"
          },
          "dvbsubs_ocr": {
            "description": "This option turns on the DVB subtitle OCR feature.\nIf it is enabled, the resulting track with text subtitles replaces the track with DVB subtitles in an output stream.\nThis option is now deprecated (replaced by `subtitles=ocr_replace`) and supported only for backward compatibility.\n",
            "type": "boolean",
            "deprecated": true,
            "x-delete-at": 23.02
          },
          "scte35": {
            "description": "This option disables processing of SCTE-35 markers from an MPEG-TS input stream.\nDeprecated since 22.12.\nAvailable ways to disable processing of SCTE-35 markers:\n1. pids option to select tracks without SCTE-35 markers\n2. hls_scte35 option from stream_config_media for hls output\n3. performing appropriate tuning pids in the transponder\n",
            "type": "boolean",
            "default": true,
            "example": true,
            "deprecated": true
          },
          "languages": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "mpegts_lang_track",
            "description": "An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`\n"
          }
        }
      },
      "stream_input_webrtc": {
        "type": "object",
        "properties": {
          "prefer_codec": {
            "description": "Choose one of the listed video codecs at the start of the publication via WebRTC.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_prefer_codec"
              }
            ],
            "example": "av1"
          },
          "transport": {
            "description": "Choose the prefered transport of the publication via WebRTC: UDP or TCP.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_transport"
              }
            ],
            "example": "udp"
          },
          "min_bitrate": {
            "description": "The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.",
            "type": "integer",
            "example": 150
          },
          "webrtc_abr": {
            "description": "Whether the adaptive bitrate mechanism is used for WebRTC publications.",
            "type": "boolean",
            "example": true
          },
          "abr_stepup": {
            "description": "Increment step for raising the bitrate to the maximum, in percent. The default step is 30%. \nIf the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.\n",
            "type": "integer"
          },
          "abr_correction": {
            "description": "The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.\nFlussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.\nThe default value is 300 kbit/s.\n",
            "type": "integer",
            "example": 200
          },
          "abr_loss_lower": {
            "type": "number",
            "description": "The lower limit of packet loss. When it is reached, Flussonic raises the bitrate. \nThat is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.\n",
            "example": 2
          },
          "abr_loss_upper": {
            "description": "The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate. \nThat is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "type": "number",
            "example": 10
          },
          "abr_stepdown": {
            "description": "A step of reducing the bitrate to the minimum. \nIf packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "type": "number"
          },
          "abr_mode": {
            "description": "The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate. \nTwo options are possible:\n\n* `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.\n* `abr_mode=1` - This mode considers only packet losses and target bitrate.\n",
            "type": "integer",
            "example": 1
          },
          "abr_debug": {
            "description": "Whether adaptive bitrate process is logged.",
            "type": "integer",
            "example": 1
          },
          "abr_cycles": {
            "description": "The number of cycles of bitrate auto-adjustment.\nAfter the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed. \nBy default, `abr_cycles`=5. \nIf `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.\n",
            "type": "integer",
            "example": 3
          }
        }
      },
      "stream_input_mixer": {
        "type": "object",
        "properties": {
          "sync": {
            "description": "This parameter is used for a mixer stream that uses other streams as its video and audio sources.\n\nIf the parameter is set to `realtime`, audio frames will be played in sync with video frames: \nif the difference between timestamps of an audio frame and a corresponding video frame is more than 2 seconds, \nthe audio frame will be played at the timestamp of the video frame. \n\nIf this parameter is set to `dts`, no synchronization is performed.\n",
            "enum": [
              "dts",
              "realtime"
            ],
            "type": "string",
            "example": "dts"
          },
          "audio_add": {
            "type": "integer",
            "description": "Moves audio timestamp forwards or backwards on a specified number of milliseconds."
          }
        }
      },
      "stream_input_mosaic2": {
        "type": "object",
        "properties": {}
      },
      "webrtc_abr_opts": {
        "type": "object",
        "properties": {
          "start_track": {
            "description": "Video track number from which playback starts. Possible values: `v1`, `v2`, `v3` and so on.\n\nIf not specified, or an audio track specified (`start_track=a3`), or a video track number does not exist, \nplayback starts with the track number in the middle of the list (e.g. `v2` if you have tracks `v1`, `v2`, and `v3`) \nand then adjusts to the bandwidth availability.\n\nIf some tracks are excluded by the query parameter `?filter=tracks:...`, Flussonic searches for an available track with a lower number up to v0. \nIf no track with a lower number was found, Flussonic searches for a closest track with a higher number.\n",
            "nullable": true,
            "type": "string",
            "example": "v2"
          }
        }
      },
      "drm_spec": {
        "type": "object",
        "properties": {
          "vendor": {
            "description": "DRM vendor. DRM (Digital Rights Management) is a content protection method where the content is encrypted and decrypted \nby a pair of keys that are generated by the key server of the DRM system.\n\nFlussonic supports the following DRM systems: EzDRM, DRM Conax, DRM Conax for Nagra, BuyDRM (KeyOS), Widevine, PallyCon, Irdeto, PlayReady DRM, GS DRM, Solocoo\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/content-protection-with-drm"
            },
            "type": "string",
            "x-atom": true,
            "x-notice": "aes128 | ezdrm | keyos | conax | pallycon | gsdrm",
            "example": "aes128"
          },
          "keyserver": {
            "description": "DRM key server.",
            "type": "string",
            "nullable": true,
            "example": "https://keyserver1.mycompany.com"
          },
          "user_keyserver": {
            "description": "The URL sent to the client for watching the content. Used for Verimatrix DRM.",
            "type": "string",
            "nullable": true,
            "example": "https://public-keyserver.mycompany.com"
          },
          "resource_id": {
            "description": "The ID of a resource (a stream or a VOD file) in DRM system, usually it is a UUID.\nThe DRM system keeps track of viewing each resource by clients.\n\nA resource ID is automatically generated for each stream or VOD file by Flussonic but it changes after renaming. \nIt is possible to set it manually to attach a stream to a particular resource or to combine several streams into one.\n",
            "type": "string",
            "format": "drm_resource_id",
            "nullable": true,
            "example": "L2sItm6"
          },
          "expires": {
            "description": "Key rotation interval, in minutes.\n\nBy default, Flussonic does not rotate enryption keys. \nSpecify this parameter to enable encryption key rotation and thus to provide a better securtiy.\n",
            "type": "integer",
            "nullable": true
          },
          "encryption": {
            "description": "If this parameter is set to `full`, all frames are encrypted. \nIf it is set to `sparse` (or empty), only the keyframes are encrypted.\n\nBy default, Flussonic encrypts only key frames. In most cases this is enough to protect the stream from an unauthorized access. \nIt also reduces the power consumption, when decrypting on the client side. \nHowever, some Smart TVs and STBs require all frames to be encrypted. \n",
            "type": "string",
            "nullable": true
          },
          "aes_key": {
            "description": "AES (Advanced Encryption Standard) key. Used for Widevine DRM.\n",
            "type": "string",
            "nullable": true
          },
          "content_id": {
            "description": "A unique identifier of the content, used for Widevine DRM.\nBy default, it is equal to the stream name.\n",
            "type": "string",
            "nullable": true
          },
          "signer": {
            "description": "A unique ID of the signer. \nFlussonic uses it to connect to the key server when using test key for Widevine DRM.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/content-protection-with-drm/widevine-drm/"
            },
            "type": "string",
            "nullable": true
          },
          "iv": {
            "description": "Initialization vector (IV) - an arbitrary number that can be used along with a secret key for data encryption. \nIt is employed only one time in any session.\nThe use of an IV prevents repetition in data encryption, making it more difficult for a hacker to break a cipher. \n\nUsually, IV is received from a DVR provider.\n",
            "type": "string",
            "nullable": true
          },
          "secret": {
            "description": "A part of the keyserver's URL when using Solcoo DRM: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/content-protection-with-drm/solocoo-drm/"
            },
            "type": "string",
            "nullable": true
          },
          "site": {
            "description": "A part of the keyserver's URL when using Solcoo DRM: `https://SITE.solocoo.tv/SITEadmintools/papi/SECRET/method`.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/content-protection-with-drm/solocoo-drm/"
            },
            "type": "string",
            "nullable": true
          },
          "fp": {
            "description": "Whether to use FairPlay system for key generation. \nIf set to `false`, the requests for FairPlay encryption key are disabled.\nUsed for Solocoo DRM.\n",
            "type": "string",
            "nullable": true
          },
          "account_id": {
            "description": "ID of the Irdeto DRM account. Ask your Irdeto manager for it.",
            "type": "string",
            "nullable": true
          },
          "ic_host": {
            "description": "A hostname of Irdeto DRM key server. Ask your Irdeto manager for it.",
            "type": "string",
            "nullable": true
          },
          "password": {
            "description": "A password for authorization of a user on a key server. Used for Irdeto DRM and EZDRM.",
            "type": "string",
            "nullable": true
          },
          "user_name": {
            "description": "A user name of the Irdeto DRM user. Ask your Irdeto manager for it.",
            "type": "string",
            "nullable": true
          },
          "user": {
            "description": "A user name for authorization of a user on a key server. Used for EZDRM.",
            "type": "string",
            "nullable": true
          },
          "keyseed": {
            "description": "An arbitrary Base64-encoded string of 30 bytes. \nIt is used for PlayReady DRM and is necessary for PlayReady to create an encryption key.\n",
            "type": "string",
            "nullable": true
          },
          "key_id": {
            "description": "A key ID (hash code of a stream name) used for an encryption key generation. Used for PlayReady DRM.",
            "type": "string",
            "nullable": true,
            "example": "6f651ae1-dbe4-4434-bcb4-690d1564c41c"
          },
          "userkey": {
            "description": "A unique identifier of the user in Buy DRM.\n",
            "type": "string",
            "nullable": true
          },
          "enc_token": {
            "description": "An API authentication token that is generated when you sign up for the PallyCon service at https://login.pallycon.com/.\nUsed for PallyCon DRM.\n",
            "type": "string",
            "nullable": true
          },
          "user_path": {
            "description": "A custom key server path for Conax DRM.",
            "type": "string",
            "nullable": true,
            "example": "12345/nks/conax"
          },
          "dump_url": {
            "description": "Whether the requested encryption URL is logged. \n",
            "type": "boolean",
            "nullable": true
          },
          "hls_ext_x_key_iv": {
            "description": "This parameter is used for encryption of HLS streams.\nFor successful playback of an AES128 encrypted HLS streams on some modern devices (running on Tizen 5), \nset this pareameter to `false`.\n",
            "type": "boolean",
            "nullable": true
          },
          "systems": {
            "description": "This parameter is used for Conax DRM for Nagra Security Services Platform.\n\nIf you turned off some of the systems (FairPlay, PlayReady, or Widevine) in your Nagra account, you should specify the systems that remain in use. \nOtherwise, an error will occur in Conax, and it will be impossible to play the stream.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/content-protection-with-drm/conax-drm-for-nagra-security-services-platform/#configuring-the-drm-systems-in-use"
            },
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/drm_system"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "la_url": {
            "description": "License URL, used for PlayReady DRM.",
            "type": "string",
            "format": "url",
            "nullable": true
          }
        },
        "required": [
          "vendor"
        ]
      },
      "named_by": {
        "type": "string",
        "oneOf": [
          {
            "const": "config",
            "description": "Media is described in file on local disk"
          },
          {
            "const": "user",
            "description": "Media was started and configured by user request: play or publish\n"
          },
          {
            "const": "remote",
            "description": "Media was sourced from another streamer via `source` directive"
          },
          {
            "const": "external",
            "description": "Media was configured via config_external backend"
          }
        ]
      },
      "backup_config": {
        "type": "object",
        "properties": {
          "file": {
            "description": "Path to the backup file in a VOD location on the server (**not on the local disk!**). \nThe backup file is played to fill in a time interval when the source is down.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/source-failover/"
            },
            "type": "string",
            "nullable": true,
            "example": "vod/blank.mp4"
          },
          "timeout": {
            "description": "The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending frames. \nThe important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.\nThis option takes any type of frames into account. \n\nIf you do not specify timeout specifically for a fallback source, then in the absence of frames, `source_timeout` of the main source will be used.\n",
            "type": "integer",
            "nullable": true,
            "example": 10
          },
          "audio_timeout": {
            "description": "The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending audio frames.",
            "type": "integer",
            "nullable": true,
            "example": 5
          },
          "video_timeout": {
            "description": "The time (in seconds) for Flussonic to switch to the fallback source if the main source stops sending video frames.",
            "type": "integer",
            "nullable": true,
            "example": 4
          },
          "transcode": {
            "description": "Whether or not to transcode the backup file. Set to `True` by default. \nIf set to `False`, backup file frames will bypass as-is to the output stream.\n\nShould not be set to `False` unless the backup file has the same stream characteristics\nas the live stream.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/live-streaming/source-failover/#live-sources-backup_transcode"
            },
            "type": "boolean",
            "nullable": true
          },
          "dvr": {
            "description": "Whether or not to record a backup to DVR. \nSet to `False` by default (backup is not recorded).\n",
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "drm_system": {
        "enum": [
          "widevine",
          "fairplay",
          "playready"
        ],
        "type": "string"
      },
      "auth_url": {
        "anyOf": [
          {
            "type": "boolean",
            "deprecated": true,
            "x-delete-at": 23.02
          },
          {
            "enum": [
              "mocked"
            ],
            "type": "string",
            "deprecated": true,
            "x-delete-at": 23.02
          },
          {
            "type": "string",
            "format": "url"
          },
          {
            "type": "string",
            "oneOf": [
              {
                "const": "true",
                "description": "Allow all playback sessions. Use the value to override template value."
              }
            ]
          }
        ]
      },
      "dvr_info": {
        "type": "object",
        "properties": {
          "from": {
            "type": "integer",
            "format": "utc",
            "description": "The UTC timestamp of the first recording in this archive.",
            "example": 1641045644
          },
          "depth": {
            "type": "integer",
            "format": "seconds",
            "description": "The time interval between the start of the *first* recording segment and the end of the *last* one.",
            "example": 259200
          },
          "ranges": {
            "description": "The list of DVR ranges.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_range"
                }
              ]
            },
            "type": "array"
          },
          "locks": {
            "description": "The list of DVR locks.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_range"
                }
              ]
            },
            "type": "array"
          },
          "motion_log": {
            "description": "The list of events from the motion detector (if it is enabled).",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_motion_event"
                }
              ]
            },
            "type": "array"
          },
          "bytes": {
            "description": "The size of the recorded archive.",
            "type": "integer",
            "format": "bytes",
            "example": 129600000000
          },
          "disk_size": {
            "description": "The size of the disk where the archive is recorded.",
            "type": "integer",
            "format": "bytes",
            "example": 1099511627776
          },
          "duration": {
            "type": "integer",
            "format": "seconds",
            "description": "A total duration of the recorded segments, excluding recording gaps.",
            "example": 172800
          }
        },
        "required": [
          "from",
          "depth",
          "ranges"
        ]
      },
      "cluster_ingest_config": {
        "type": "object",
        "properties": {
          "capture_at": {
            "description": "Preferred server to run the main stream on.",
            "type": "string",
            "nullable": true
          }
        }
      },
      "url_prefix": {
        "anyOf": [
          {
            "enum": [
              false
            ],
            "type": "boolean"
          },
          {
            "type": "string"
          }
        ]
      },
      "output_mpegts_pids": {
        "type": "object",
        "properties": {
          "pmt": {
            "description": "PID  of the elementary stream that contains Program Map Table (PMT) in the outgoing MPEG-TS stream.\n\nPMT contains the description of each program and lists the PIDs of elementary streams associated with that program.\nFor instance, a transport stream used in digital television might contain three programs, to represent three television channels. \nSuppose each channel consists of one video stream, one or two audio streams, and any necessary metadata. \nA receiver wishing to decode one of the three channels merely has to decode the payloads of each PID associated with its program. \nIt can discard the contents of all other PIDs.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ],
            "nullable": true
          },
          "pcr": {
            "description": "PID of the elementary stream that contains PCR (Program Clock Reference) in the outgoing MPEG-TS stream.\n\nPCR is the time label used for synchronization of a stream playback with real time. \nAdditionally, for DVB streams it is used for managing a decoder and its buffer. \nIn this case, PCR gives a signal to the frames with DTS<PCR to be sent to the decoder from the buffer. \nThis mechanism allows to compensate different sizes of frames: if a frame is too big to be played in time with a specified FPS, the frames from the buffer are played.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ],
            "nullable": true
          },
          "sdt": {
            "description": "PID  of the elementary stream that contains Service Description Table (SDT) in the outgoing MPEG-TS stream.\nSDT provides information about services contained in MPEG-TS stream.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ],
            "nullable": true
          },
          "media": {
            "description": "Information about a particular media track.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_pid"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "default": {
            "description": "The default algorithm of selecting PID for a track.\n\n* `auto`: track PID = PMT PID + track ID, \nwhere PMT PID is the PID of Program Map Table and track ID is a number of the track set by Flussonic \n(usually, all video tracks and then all audio tracks are numbered starting from 1).\n* `increment`: track PID = previous track PID + 1.\n",
            "enum": [
              "auto",
              "increment"
            ],
            "type": "string",
            "nullable": true
          }
        }
      },
      "output_mpegts_ac3": {
        "type": "string",
        "enum": [
          "system_b",
          "system_a",
          "keep"
        ],
        "example": "keep"
      },
      "bm_display_mode": {
        "enum": [
          "ntsc",
          "nt23",
          "pal",
          "ntsp",
          "palp",
          "23ps",
          "24ps",
          "Hp25",
          "Hp29",
          "Hp30",
          "Hp47",
          "Hp48",
          "Hp50",
          "Hp59",
          "Hp60",
          "Hp95",
          "Hp96",
          "Hp10",
          "Hp11",
          "Hp12",
          "Hi50",
          "Hi59",
          "Hi60",
          "hp50",
          "hp59",
          "hp60",
          "2k23",
          "2k24",
          "2k25",
          "2d23",
          "2d24",
          "2d25",
          "2d29",
          "2d30",
          "2d47",
          "2d48",
          "2d50",
          "2d59",
          "2d60",
          "2d95",
          "2d96",
          "2d10",
          "2d11",
          "2d12",
          "4k23",
          "4k24",
          "4k29",
          "4k30",
          "4k47",
          "4k48",
          "4k50",
          "4k59",
          "4k60",
          "4k95",
          "4k96",
          "4k10",
          "4k11",
          "4k12",
          "4d23",
          "4d24",
          "4d25",
          "4d29",
          "4d30",
          "4d47",
          "4d48",
          "4d50",
          "4d59",
          "4d60",
          "4d95",
          "4d96",
          "4d10",
          "4d11",
          "4d12",
          "8k23",
          "8k24",
          "8k25",
          "8k29",
          "8k30",
          "8k47",
          "8k48",
          "8k50",
          "8k59",
          "8k60",
          "8d23",
          "8d24",
          "8d25",
          "8d29",
          "8d30",
          "8d47",
          "8d48",
          "8d50",
          "8d59",
          "8d60",
          "vga6",
          "svg6",
          "wxg5",
          "wxg6",
          "sxg5",
          "sxg6",
          "uxg5",
          "uxg6",
          "wux5",
          "wux6",
          "1945",
          "1946",
          "wqh5",
          "wqh6",
          "wqx5",
          "wqx6",
          "rwci",
          "rwcc"
        ],
        "type": "string"
      },
      "video_format": {
        "type": "string",
        "oneOf": [
          {
            "const": "pal",
            "description": "pal 720x576 @ 50Hz interlace SMPTE-259"
          },
          {
            "const": "625i50",
            "description": "Similar PAL"
          },
          {
            "const": "ntsc",
            "description": "NTSC 720x480 @ 59.94Hz interlace SMPTE-259"
          },
          {
            "const": "525i29.97",
            "description": "Similar NTSC"
          },
          {
            "const": "525i29",
            "description": "Similar NTSC"
          },
          {
            "const": "720p23.98",
            "description": "1280x720 @ 23.98Hz progressive SMPTE-296"
          },
          {
            "const": "720p23",
            "description": "Similar 720p23.98"
          },
          {
            "const": "720p24"
          },
          {
            "const": "720p25"
          },
          {
            "const": "720p29.97"
          },
          {
            "const": "720p29"
          },
          {
            "const": "720p30"
          },
          {
            "const": "720p50"
          },
          {
            "const": "720p59.94"
          },
          {
            "const": "720p59"
          },
          {
            "const": "720p60"
          },
          {
            "const": "1080p23.98",
            "description": "1920x1080 @ 23.98Hz progressive SMPTE-274"
          },
          {
            "const": "1080p23"
          },
          {
            "const": "1080p24"
          },
          {
            "const": "1080p25"
          },
          {
            "const": "1080p29.97"
          },
          {
            "const": "1080p29"
          },
          {
            "const": "1080p30"
          },
          {
            "const": "1080psf23.98",
            "description": "1920x1080 @ 23.98Hz progressive Progressive segmented Frame SMPTE-274"
          },
          {
            "const": "1080psf23"
          },
          {
            "const": "1080psf24"
          },
          {
            "const": "1080psf25"
          },
          {
            "const": "1080psf29.97"
          },
          {
            "const": "1080psf29"
          },
          {
            "const": "1080psf30"
          },
          {
            "const": "1080i50"
          },
          {
            "const": "1080i59.94"
          },
          {
            "const": "1080i60"
          },
          {
            "const": "1080p50",
            "description": "1920x1080 @ 50Hz progressive annex A or annex B depending hardware SMPTE-274"
          },
          {
            "const": "1080p50b",
            "description": "1920x1080 @ 50Hz progressive annex B SMPTE-274"
          },
          {
            "const": "1080p59.94"
          },
          {
            "const": "1080p59"
          },
          {
            "const": "1080p59.94b"
          },
          {
            "const": "1080p59b"
          },
          {
            "const": "1080p60"
          },
          {
            "const": "1080p60b"
          },
          {
            "const": "2160p50",
            "description": "4k 3840x2160 @ 50Hz progressive SMPTE-2036"
          },
          {
            "const": "2160p50b"
          },
          {
            "const": "2160p59.94"
          },
          {
            "const": "2160p59"
          },
          {
            "const": "2160p59.94b"
          },
          {
            "const": "2160p59"
          },
          {
            "const": "2160p60"
          },
          {
            "const": "2160p60b"
          },
          {
            "const": "2160p23"
          },
          {
            "const": "2160p24"
          },
          {
            "const": "2160p25"
          },
          {
            "const": "2160p29"
          },
          {
            "const": "2160p30"
          }
        ]
      },
      "transponder_push": {
        "properties": {
          "url": {
            "description": "Push URL for the MPTS stream. Usually it is a `udp://` multicast address and port.\n",
            "type": "string"
          },
          "multicast_loop": {
            "description": "The multicast socket option that enables ingesting the sent data back to the transponder.\nUse for test purposes, e.g. if the same server creates MTPS and splits MPTS to separate programs.\n",
            "type": "boolean",
            "default": true
          },
          "tos": {
            "description": "ToS byte in the IP packages of the multicasted data.",
            "type": "integer",
            "default": 0
          },
          "standby": {
            "description": "Monitoring multicast group and stop pushing if another publisher presented",
            "nullable": true,
            "type": "boolean"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "ts_descriptor": {
        "type": "object",
        "properties": {
          "tag": {
            "type": "integer",
            "description": "Identifier of the descriptor."
          },
          "hex": {
            "type": "string",
            "format": "hexbinary",
            "description": "Descriptor data."
          }
        },
        "required": [
          "tag",
          "hex"
        ]
      },
      "ts_timeouts": {
        "properties": {
          "service_type": {
            "type": "integer",
            "nullable": true,
            "description": "The type of the program."
          },
          "media_info": {
            "type": "integer",
            "nullable": true,
            "description": "The timeout value."
          }
        },
        "type": "object"
      },
      "ts_service_type": {
        "anyOf": [
          {
            "type": "integer"
          },
          {
            "type": "string",
            "enum": [
              "none",
              "digital_tv",
              "digital_radio",
              "teletext",
              "nvod_reference",
              "nvod_shifted",
              "mosaic",
              "fm_radio",
              "dvb_srm",
              "digital_radio_aac",
              "mosaic_avc",
              "data",
              "common_interface",
              "rcs_map",
              "rcs_fls",
              "dvb_mhp",
              "digital_tv_mpeg2_hd",
              "digital_tv_avc_sd",
              "nvod_shifted_avc_sd",
              "nvod_reference_avc_sd",
              "digital_tv_avc_hd",
              "digital_tv_avc_stereo_hd",
              "nvod_shifted_avc_stereo_hd",
              "nvod_reference_avc_stereo_hd",
              "digital_tv_hevc",
              "digital_tv_hevc_uhd"
            ]
          }
        ]
      },
      "ts_versions": {
        "properties": {
          "psi": {
            "description": "Global version for all PSI tables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          },
          "pat": {
            "description": "The version of PAT table.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          },
          "pmt": {
            "description": "The version of PMT table.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          },
          "nit": {
            "description": "The version of NIT table.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          },
          "sdt": {
            "description": "The version of SDT table.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          },
          "cat": {
            "description": "The version of CAT table.",
            "allOf": [
              {
                "$ref": "#/components/schemas/psi_version"
              }
            ],
            "nullable": true
          }
        },
        "type": "object"
      },
      "transponder_time_offset": {
        "properties": {
          "country": {
            "description": "The country code.",
            "type": "string"
          },
          "region": {
            "description": "The region code.",
            "type": "integer"
          },
          "time_of_change": {
            "description": "Date and time when the time change takes place.",
            "allOf": [
              {
                "$ref": "#/components/schemas/iso8601"
              }
            ],
            "nullable": true
          },
          "local_time_offset": {
            "description": "The current offset time from UTC.",
            "type": "string",
            "nullable": true
          },
          "next_time_offset": {
            "description": "The next offset time after the change.",
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "country"
        ],
        "type": "object"
      },
      "ts_eit_intervals": {
        "properties": {
          "actual": {
            "description": "Period for the actual transponder.",
            "type": "integer",
            "nullable": true
          },
          "other": {
            "description": "Period for the other transponder.",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object"
      },
      "transponder_eit": {
        "type": "object",
        "properties": {
          "max_bitrate": {
            "description": "Maximum bitrate for the transponder's EIT EPG.",
            "type": "integer",
            "format": "max_bitrate",
            "nullable": true
          },
          "xmltv_url": {
            "description": "Directory for storing the XMLTV EPG files.",
            "type": "string",
            "nullable": true
          },
          "keep_epg": {
            "description": "Period for storing the XMLTV files.",
            "type": "integer",
            "format": "seconds",
            "nullable": true
          },
          "intervals_pf": {
            "description": "Periods for sending the present/following events.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_eit_intervals"
              }
            ],
            "nullable": true
          },
          "intervals_schedule": {
            "description": "Periods for sending the event schedules.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_eit_intervals"
              }
            ],
            "nullable": true
          }
        }
      },
      "transponder_program": {
        "type": "object",
        "properties": {
          "program_id": {
            "description": "Identifier of the program within the transponder.",
            "allOf": [
              {
                "$ref": "#/components/schemas/program_id"
              }
            ],
            "x-primary-key": true
          },
          "source": {
            "description": "The stream that is in use as the program source.",
            "type": "string",
            "format": "media_name",
            "nullable": true
          },
          "lcn": {
            "description": "Logical channel number.",
            "type": "integer",
            "nullable": true
          },
          "service_type": {
            "description": "Information about the program type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_service_type"
              }
            ],
            "nullable": true
          },
          "vb": {
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "description": "This property is no longer supported, use individual [`bitrate`](https://flussonic.com/doc/video-playback/udp-multicast-with-constant-bitrate/#settings-bitrates-of-tracks) option for a program PID.",
            "deprecated": true,
            "x-delete-at": 22.11
          },
          "title": {
            "description": "The program title.",
            "type": "string",
            "nullable": true
          },
          "pids": {
            "description": "The list of PIDs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_mpegts_pids"
              }
            ],
            "nullable": true
          },
          "eit_title": {
            "description": "The name of the EIT.",
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "program_id"
        ]
      },
      "transponder_config": {
        "properties": {
          "name": {
            "description": "The name of the transponder.",
            "type": "string",
            "format": "media_name",
            "x-primary-key": true
          },
          "pushes": {
            "description": "The list of pushes for the transponder.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_push"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "bitrate": {
            "description": "Transponder bitrate.",
            "type": "integer",
            "format": "speed",
            "nullable": true
          },
          "provider": {
            "description": "Provider of the transponder.",
            "type": "string",
            "nullable": true
          },
          "network_name": {
            "description": "The name of the TV network.",
            "type": "string",
            "nullable": true
          },
          "ts_stream_id": {
            "description": "The identifier of the transport stream for the transponder.",
            "type": "integer",
            "nullable": true
          },
          "network_id": {
            "description": "Identifier of the delivery network.",
            "type": "integer",
            "nullable": true
          },
          "original_network_id": {
            "description": "Identifier of the original delivery network. The same original network is used for NIT and SDT.",
            "type": "integer",
            "nullable": true
          },
          "ts_descriptors": {
            "description": "The list of transport stream descriptors. Descriptors are added to NIT and SDT.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ts_descriptor"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "timeouts": {
            "description": "The list of timeouts for autodetect of provider, title, and service_type of the programs.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_timeouts"
              }
            ],
            "nullable": true
          },
          "programs": {
            "description": "The list of programs in the transponder.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_program"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "time_offsets": {
            "description": "The list of time offsets.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_time_offset"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "versions": {
            "description": "Versions of PSI tables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_versions"
              }
            ],
            "nullable": true
          },
          "others": {
            "description": "The list of other transponders on the network.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_other"
                }
              ]
            },
            "type": "array",
            "default": []
          },
          "eit": {
            "description": "Transponder's program guide in EIT format.",
            "allOf": [
              {
                "$ref": "#/components/schemas/transponder_eit"
              }
            ],
            "nullable": true
          },
          "video_buffer": {
            "description": "The size of the video buffer for the transponder.",
            "type": "integer",
            "nullable": true
          },
          "prebuffer": {
            "description": "The length of multiplexer input buffer.\nThe higher value makes the multiplexer more robust to non-uniform inputs.\nThe lower value reduces input-to-output latency, but requires more stable bitrate (CBR) on input.\n",
            "format": "milliseconds",
            "default": 300,
            "example": 800,
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object"
      },
      "transponder_other": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the other transponder on the network.",
            "type": "string",
            "format": "media_name",
            "x-primary-key": true
          }
        },
        "required": [
          "name"
        ]
      },
      "peer_stats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/server_stats_whoami"
          },
          {
            "$ref": "#/components/schemas/server_stats_streamer"
          },
          {
            "$ref": "#/components/schemas/server_stats_network"
          },
          {
            "type": "object",
            "properties": {
              "client_count": {
                "type": "integer",
                "format": "client_count",
                "nullable": true,
                "deprecated": true
              },
              "output_bitrate": {
                "type": "integer",
                "format": "speed",
                "nullable": true,
                "deprecated": true
              },
              "stream_count": {
                "type": "integer",
                "nullable": true,
                "deprecated": true
              },
              "error": {
                "type": "string",
                "nullable": true
              }
            }
          }
        ]
      },
      "peer_config": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string",
            "format": "server_name",
            "description": "Globally unique server name.",
            "x-primary-key": true
          },
          "stats": {
            "description": "Statistics on peers in the cluster.",
            "allOf": [
              {
                "$ref": "#/components/schemas/peer_stats"
              }
            ],
            "nullable": true
          },
          "api_url": {
            "type": "string",
            "format": "url",
            "description": "The internal address for internal communication between the server and the peers. \nInternal communications are based on API so this is basically an URL for API calls. This URL does not have to be public.\nThe API URL can include a port number, or the port number can be set by the `admin_http` parameter.\n",
            "nullable": true
          },
          "public_payload_url": {
            "description": "The public address that is exposed to clients. It can also contain a port number.\nThe client will be redirected to this URL and port when requesting for the stream captured on the peer\neven if other `http` port is set in the peer's own config.\n",
            "type": "string",
            "format": "url",
            "nullable": true
          },
          "public": {
            "description": "The public address that is exposed to clients.",
            "type": "string",
            "format": "url",
            "nullable": true,
            "deprecated": true,
            "x-alias": "public_payload_url"
          },
          "private_payload_url": {
            "description": "The internal address for communication in a local network (by default, it is equal to API URL).\n",
            "type": "string",
            "format": "url",
            "nullable": true
          },
          "fetch_timeout": {
            "description": "How often the peer will try to get the data from the remote server via internal API.",
            "type": "integer",
            "format": "milliseconds",
            "nullable": true
          },
          "stale_timeout": {
            "description": "The time after which deleted streams on this server are considered to be inactive \nand cannot be used in the `cluster_ingest` mechanism.\n",
            "type": "integer",
            "format": "milliseconds",
            "nullable": true
          },
          "channel_limit": {
            "description": "Maximal number of streams.",
            "type": "integer",
            "nullable": true
          },
          "cpu_limit": {
            "description": "CPU limit in percents.",
            "type": "integer",
            "format": "percents",
            "nullable": true
          },
          "cluster_key": {
            "description": "The key for authorization for inter-Flussonic connections.\nAll cluster peers should have the same cluster key.\n",
            "type": "string",
            "nullable": true
          },
          "max_bitrate": {
            "description": "Maximal output bitrate of the peer.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "deprecated": true
          }
        }
      },
      "balancer_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "media_name",
            "description": "Globally unique balancer name.",
            "x-primary-key": true
          },
          "servers": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/balancer_server_config"
                }
              ]
            },
            "nullable": true,
            "description": "Balancer will distribute requests between these servers."
          },
          "peers": {
            "description": "Configuration of the peers.",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/peer_config"
                }
              ]
            },
            "nullable": true,
            "deprecated": true
          },
          "mode": {
            "description": "Balancing mode",
            "type": "string",
            "default": "bitrate",
            "oneOf": [
              {
                "title": "Usage",
                "const": "usage",
                "description": "Bandwidth usage"
              },
              {
                "title": "Clients",
                "const": "clients",
                "description": "Total clients number"
              },
              {
                "title": "Bitrate",
                "const": "bitrate",
                "description": "Total output bitrate"
              },
              {
                "title": "Streams",
                "const": "streams",
                "description": "Streams number"
              }
            ],
            "nullable": true
          }
        }
      },
      "balancer_server_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Hostname of the peer. Can refer to globally defined peer.",
            "x-primary-key": true
          },
          "max_bitrate": {
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "description": "Maximum allowed bitrate, request is redirecting if current bitrate is lower."
          },
          "countries": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iso3166"
            },
            "nullable": true,
            "description": "Client will be redirected to the peer if its IP belongs to one of these countries."
          },
          "countries_default": {
            "type": "boolean",
            "nullable": true,
            "description": "This flag allows to redirect a request to this peer if \"countries\" list not matched."
          }
        }
      },
      "source_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/source_specific_config"
          },
          {
            "$ref": "#/components/schemas/stream_config_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_onpremises"
          }
        ]
      },
      "source_group_config": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Tha name of the source group.",
            "type": "string",
            "format": "group_name",
            "nullable": true
          },
          "auth": {
            "description": "Configuration of the authorization backend (play session **only**). To be replaced with `on_play` configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ],
            "nullable": true,
            "deprecated": true,
            "x-alias": "on_play"
          },
          "on_play": {
            "description": "Path to auth backend, either HTTP URL or path to script on disk. Play sessions only.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ],
            "nullable": true
          },
          "cache": {
            "description": "Cache configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/cache_spec"
              }
            ],
            "nullable": true
          },
          "segment_duration": {
            "description": "The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH. \n",
            "allOf": [
              {
                "$ref": "#/components/schemas/segment_duration"
              }
            ],
            "nullable": true
          },
          "dvr": {
            "description": "DVR configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_dvr_spec"
              }
            ],
            "nullable": true
          }
        }
      },
      "source_specific_config": {
        "type": "object",
        "properties": {
          "url": {
            "description": "URL and port of the remote server to get streams from.",
            "type": "string",
            "format": "hostport",
            "x-primary-key": true
          },
          "prefix": {
            "description": "The prefix used for the streams on the remote server from which the peer gets them.\n",
            "type": "string",
            "format": "media_name",
            "nullable": true
          },
          "stats": {
            "description": "Statistics of the peer.",
            "allOf": [
              {
                "$ref": "#/components/schemas/peer_stats"
              }
            ],
            "nullable": true
          },
          "streams": {
            "description": "The list of streams coming from the source. Replaced with `only` and `except` in newer versions.",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/stream_stats"
                }
              ]
            },
            "deprecated": true,
            "nullable": true
          },
          "only": {
            "description": "White list of streams. \nThe items of the array may be individual stream names or values like `prefix/*`\nwhich stands for all streams with the given prefix.\n",
            "type": "array",
            "items": {
              "type": "string",
              "format": "media_name"
            },
            "nullable": true
          },
          "except": {
            "description": "Black list of streams. Higher priority than `only`.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "media_name"
            },
            "nullable": true
          },
          "group_config": {
            "description": "Configuration applied to the specific group of streams (all or limited by `only` and `except`) received from the sources.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/source_group_config"
            },
            "nullable": true,
            "x-key-type": "string"
          },
          "cluster_key": {
            "description": "Cluster ingest stream key.",
            "type": "string",
            "nullable": true
          }
        }
      },
      "logo_file": {
        "type": "object",
        "properties": {
          "stream_names": {
            "description": "List of streams that use this logo",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [],
            "readOnly": true
          },
          "content": {
            "description": "Payload of this logo",
            "type": "string",
            "format": "byte"
          },
          "content_type": {
            "description": "Content type of this logo. Calculated from file name extension\n",
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        }
      },
      "disk_file": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The file or directory name.",
            "type": "string",
            "format": "media_name",
            "nullable": true,
            "examples": {
              "default": {
                "value": "vod/bunny.mp4"
              },
              "bunny1": {
                "value": "vod/bunny1.mp4"
              },
              "bunny2": {
                "value": "vod/bunny2.mp4"
              },
              "bunny3": {
                "value": "vod/bunny3.mp4"
              }
            }
          },
          "prefix": {
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "type": "string",
            "format": "media_name",
            "nullable": true,
            "examples": {
              "default": {
                "value": "vod"
              },
              "bunny1": {
                "value": "vod1"
              },
              "bunny2": {
                "value": "vod2"
              },
              "bunny3": {
                "value": "vod3"
              }
            }
          },
          "url": {
            "description": "URL of the file or directory.",
            "type": "string",
            "format": "url",
            "nullable": true,
            "examples": {
              "default": {
                "value": "/storage/bunny.mp4"
              },
              "bunny1": {
                "value": "/storage/bunny1.mp4"
              },
              "bunny2": {
                "value": "/storage/bunny2.mp4"
              },
              "bunny3": {
                "value": "/storage/bunny3.mp4"
              }
            }
          },
          "folder": {
            "description": "Name of the folder containing the file or directory.",
            "type": "string",
            "nullable": true,
            "example": "example"
          },
          "subpath": {
            "description": "Subpath to the file or directory in the storage.",
            "type": "string",
            "nullable": true,
            "examples": {
              "default": {
                "value": "bunny.mp4"
              },
              "bunny1": {
                "value": "bunny1.mp4"
              },
              "bunny2": {
                "value": "bunny2.mp4"
              },
              "bunny3": {
                "value": "bunny3.mp4"
              }
            }
          },
          "bytes": {
            "description": "File size in bytes.",
            "type": "integer",
            "nullable": true,
            "example": 42309561
          },
          "is_directory": {
            "description": "Whether it is a directory.",
            "type": "boolean",
            "default": false,
            "example": false
          },
          "is_multibitrate_directory": {
            "description": "Whether it is a directory with multi-bitrate content.",
            "type": "boolean",
            "default": false,
            "example": false
          },
          "opened": {
            "description": "Whether the file or directory is currently opened.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "stats": {
            "description": "Statistics of the file usage.",
            "allOf": [
              {
                "$ref": "#/components/schemas/disk_file_stats"
              }
            ],
            "nullable": true
          }
        }
      },
      "disk_file_stats": {
        "type": "object",
        "properties": {
          "worker_count": {
            "description": "Number of worker threads on the server executing the task of playing the file.",
            "type": "integer",
            "nullable": true,
            "example": 1
          },
          "client_count": {
            "description": "Number of clients playing the file.",
            "type": "integer",
            "format": "client_count",
            "nullable": true,
            "examples": {
              "default": {
                "value": 2
              },
              "bunny1": {
                "value": 1
              },
              "bunny2": {
                "value": 10
              },
              "bunny3": {
                "value": 5
              }
            }
          },
          "bytes_in": {
            "description": "Number of bytes read from the disk.",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 1700923231
          },
          "bytes_out": {
            "description": "Number of bytes downloaded form the disk.",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 1700923231
          },
          "media_info": {
            "description": "Technical information about the output media content.",
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ],
            "nullable": true
          }
        }
      },
      "vod_storage": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "The storage (on the disk or on another server) that Flussonic will scan for VOD files.\nIf it is a path on the disk, it should be specified relating to the disk root.\n\nIt is possible to specify multiple storages for one VOD location. When Flussonic gets the URL for playing the file, it finds the prefix in this URL, \ncuts the path after it and consequently searches for this path in all specified storages.\n",
            "example": "/storage"
          },
          "extra": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true,
            "description": "Some additional options."
          }
        }
      },
      "vod_config": {
        "type": "object",
        "properties": {
          "prefix": {
            "description": "The unique name of VOD location. \n\nIt is used as a prefix in file playback requests to explicitly specify where the system should find the files for playing. \nAll the path after the prefix will be cut and added to the specified path on the disk (the storage configured for this VOD location). \nThus, the system will find the file on the disk and play it.\n",
            "type": "string",
            "format": "media_name",
            "x-primary-key": true,
            "example": "movies"
          },
          "auto_mbr": {
            "description": "Turns on automatic creation of a multi-bitrate HLS playlist from several files with different bitrates.",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/vod-file-broadcasting/a-multibitrate-playlist-made-from-files/#vod-auto_mbr-page"
            },
            "type": "boolean",
            "default": false
          },
          "position": {
            "type": "integer",
            "format": "sort_index",
            "description": "If an order of VOD locations is declared, it is a position of the this VOD location in the order.",
            "nullable": true,
            "x-notice": "only for stream",
            "example": 1
          },
          "disabled": {
            "description": "Whether this VOD location is disabled.",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "storages": {
            "description": "The directories (on disk or on another server) that Flussonic scans for VOD files.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/vod_storage"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "auth": {
            "description": "Configuraton of the authorization backend for play sessions **only**.",
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ],
            "nullable": true,
            "deprecated": true,
            "x-alias": "on_play"
          },
          "on_play": {
            "description": "Configuraton of the authorization backend for play sessions **only**. \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/#playback-authorization"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_spec"
              }
            ],
            "nullable": true
          },
          "cache": {
            "description": "Configuraton of the local file cache which is used for files from a cloud or an HTTP server.\n\nIf this option is enabled, a file will be downloaded to a local cache path by megabyte blocks. \nDuring playback, the file will be first read from the cache. \nThis allows to avoid multiple HTTP requests to the source for each part of data and, thus, to speed up broadcasting.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/cache_spec"
              }
            ],
            "nullable": true
          },
          "read_queue": {
            "description": "The number of simultaneous readers form disk that should wait in a queue for playing a file.",
            "type": "integer",
            "nullable": true,
            "example": 100
          },
          "max_readers": {
            "description": "The number of simultaneous requests to disk for a given prefix.",
            "type": "integer",
            "nullable": true,
            "deprecated": true,
            "example": 100
          },
          "thumbnails": {
            "description": "Configuration of thumbnails generator.",
            "allOf": [
              {
                "$ref": "#/components/schemas/thumbnails_spec"
              }
            ],
            "nullable": true
          },
          "download": {
            "description": "Enables downloading files from the URL `http://FLUSSONIC-IP:80/vod_prefix/file_subpath.mp4`. \nThe `Range` HTTP headers are supported.\n",
            "type": "boolean",
            "default": false,
            "example": false
          },
          "protocols": {
            "description": "Configuraton of play protocols.",
            "allOf": [
              {
                "$ref": "#/components/schemas/play_protocols_spec"
              }
            ],
            "nullable": true
          },
          "url_prefix": {
            "description": "The names of separate segments within a segment-based HLS or DASH playlist start with the *specified* prefix. \nThe option no longer works for *variant playlists*.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/url_prefix"
              }
            ],
            "nullable": true
          },
          "segment_duration": {
            "description": "The time, in seconds, of the segment duration. Used for the protocols like HLS or DASH.",
            "allOf": [
              {
                "$ref": "#/components/schemas/segment_duration"
              }
            ],
            "nullable": true
          },
          "logo": {
            "description": "Overlay logo.",
            "allOf": [
              {
                "$ref": "#/components/schemas/web_logo_spec"
              }
            ],
            "nullable": true
          },
          "timeout": {
            "description": "The time (in milliseconds) passed since the last file request.\nIf the file was not requested within this period, it will be closed and its resources will be deallocated.\n",
            "type": "integer",
            "nullable": true,
            "example": 3
          },
          "drm": {
            "description": "Configuraton of the content encryption (DRM).",
            "allOf": [
              {
                "$ref": "#/components/schemas/drm_spec"
              }
            ],
            "nullable": true
          },
          "add_audio_only": {
            "description": "Whether to add an audio-only version of an HLS stream. \nUsed to create App Store compliant HLS streams to deliver the content to Apple iOS devices.\nAdd audio-only HLS playlist to variant MBR playlist for iOS compliant streaming.\n",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "provider": {
            "description": "Human-readable name of the content provider. Applicable to MPEG-TS.",
            "type": "string",
            "nullable": true
          }
        }
      },
      "dvb_card_config": {
        "type": "object",
        "properties": {
          "name": {
            "description": "DVB card name.",
            "type": "string",
            "format": "dvb_card_name",
            "x-primary-key": true,
            "example": "a16"
          },
          "hw": {
            "description": "Adapter card hardware type.",
            "type": "string",
            "enum": [
              "dvb",
              "dektec_asi",
              "v4l",
              "record_input",
              "resi",
              "tbs6014"
            ],
            "nullable": true,
            "example": "dvb"
          },
          "system": {
            "description": "Adapter type. Different systems are supported besides DVB, as the configuring is similar.",
            "type": "string",
            "enum": [
              "dvbs",
              "dvbs2",
              "dvbt",
              "dvbt2",
              "dvbca",
              "dvbcb",
              "dvbcc",
              "atsc",
              "isdbt"
            ],
            "nullable": true
          },
          "adapter": {
            "description": "Adapter number.",
            "type": "integer",
            "nullable": true,
            "example": 16
          },
          "device": {
            "description": "Modulator number in adapter.",
            "type": "integer",
            "nullable": true
          },
          "frontend": {
            "description": "Frontend number.",
            "type": "integer",
            "nullable": true
          },
          "frequency": {
            "description": "The carrier frequency of the transponder for this channel, in Hz.",
            "type": "integer",
            "nullable": true,
            "example": 11606
          },
          "symbol_rate": {
            "description": "The symbol rate of the transponder, in symbols per second.\nA symbol is a pulse in digital baseband transmission.\n",
            "type": "integer",
            "nullable": true,
            "example": 27500
          },
          "int_freq": {
            "description": "Base frequency, in MHz.",
            "type": "integer",
            "nullable": true
          },
          "high_band": {
            "description": "Whether high frequency band is used.",
            "type": "boolean",
            "nullable": true
          },
          "polarization": {
            "description": "Polarization of the transponder for this channel. \nThe supported values are: \n\n * `v`- vertical linear polarization, \n * `h` - horizontal linear polarization, \n * `r` - right-hand circular polarization, \n * `l` - left-hand circular polarization.\n",
            "type": "string",
            "enum": [
              "v",
              "h",
              "r",
              "l"
            ],
            "nullable": true,
            "example": "v"
          },
          "hierarchy": {
            "description": "Constellation ratio for hierarchical transmission.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://dvb.org/wp-content/uploads/2019/12/a012_dvb-t_june_2015.pdf"
            },
            "type": "string",
            "enum": [
              "1",
              "2",
              "4",
              "none",
              "auto"
            ],
            "nullable": true
          },
          "transmission_mode": {
            "description": "DVB transmission mode.",
            "type": "string",
            "enum": [
              "1k",
              "2k",
              "8k",
              "16k",
              "32k",
              "c1",
              "c3780"
            ],
            "nullable": true
          },
          "guard_interval": {
            "description": "The mode of inserting a guard interval - a padding separating transmissions so that they do not interfere with each other.\n",
            "type": "string",
            "enum": [
              "1_128",
              "1_32",
              "1_16",
              "1_8",
              "1_4",
              "19_128",
              "19_256",
              "pn420",
              "pn595",
              "pn945"
            ],
            "nullable": true,
            "example": "1_16"
          },
          "pilot": {
            "description": "Enable, disable, or autodetect pilot tones.\n",
            "type": "string",
            "enum": [
              "auto",
              "on",
              "off"
            ],
            "nullable": true,
            "example": "auto"
          },
          "rolloff": {
            "description": "Rolloff factor, in %.\nIt is used to estimate bandwidth, together with symbol rate.\n",
            "type": "string",
            "enum": [
              "35",
              "25",
              "20"
            ],
            "nullable": true
          },
          "bandwidth": {
            "description": "Bandwidth, in Hz.",
            "type": "integer",
            "enum": [
              1712000,
              5000000,
              6000000,
              7000000,
              8000000,
              10000000
            ],
            "nullable": true,
            "example": 6000000
          },
          "code_rate_lp": {
            "description": "Low priority stream code rate.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvb_fec"
              }
            ],
            "nullable": true
          },
          "code_rate_hp": {
            "description": "High priority stream code rate.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvb_fec"
              }
            ],
            "nullable": true
          },
          "modulation": {
            "description": "DVB-C modulation method.",
            "type": "string",
            "enum": [
              "auto",
              "qpsk",
              "qam16",
              "qam32",
              "qam64",
              "qam128",
              "qam256",
              "qam_auto",
              "psk8",
              "apsk16",
              "apsk32",
              "vsb8",
              "vsb16",
              "dqpsk",
              "qam4nr"
            ],
            "nullable": true,
            "example": "auto"
          },
          "disabled": {
            "description": "Whether this DVB card is disabled.",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "comment": {
            "description": "Any text comment.",
            "type": "string",
            "nullable": true
          },
          "stats": {
            "description": "Statistic information about the captured signal.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvb_card_stats"
              }
            ],
            "nullable": true
          },
          "serial": {
            "description": "Serial number of the card, used for capturing from DekTec ASI cards.",
            "type": "integer",
            "nullable": true
          },
          "port": {
            "description": "Port number, used for capturing from DekTec ASI cards.",
            "type": "integer",
            "nullable": true
          },
          "record_input": {
            "description": "Configuration of DVB input recording as-is.",
            "allOf": [
              {
                "$ref": "#/components/schemas/record_input_spec"
              }
            ],
            "nullable": true
          },
          "compensate_time_drift_ppm": {
            "description": "Max source's internal clock drift to compensate, rounding to six decimal places.",
            "type": "integer",
            "nullable": true
          },
          "plp_stream_id": {
            "description": "PLP stream selector. Used in DVB-T2.",
            "type": "integer",
            "nullable": true
          },
          "attenuator": {
            "description": "Attenuation of the signal level. Takes values from 0 to 10.\n",
            "type": "integer",
            "nullable": true
          },
          "interleave": {
            "description": "Use interleaver.\nThe interlaver disperses sequence of bits in bit stream to minimize effect of burst errors during transmission.\n",
            "type": "integer",
            "minimum": 0,
            "maximum": 15,
            "nullable": true
          },
          "gain": {
            "description": "Adjust the output gain to the specified value in dB.",
            "type": "integer",
            "nullable": true
          },
          "input_bitrate": {
            "description": "Input bitrate, in Mbps.",
            "type": "integer",
            "nullable": true
          },
          "video_device": {
            "description": "The video device to capture video from Stream Labs SDI/ASI cards.\nIt is actually a path to a device file created on the disk by Video4Linux.\n",
            "type": "string",
            "nullable": true,
            "example": "/dev/video0"
          }
        },
        "required": [
          "name"
        ]
      },
      "dvb_card_stats": {
        "type": "object",
        "properties": {
          "ber": {
            "description": "Bit error rate. It is the percent of bit errors from total number of transferred bits.\n",
            "type": "integer",
            "nullable": true,
            "example": 5
          },
          "strength_raw": {
            "description": "Signal strength, as a raw 16-bit number received from DVB API.",
            "type": "integer",
            "nullable": true,
            "example": 62446
          },
          "strength": {
            "description": "Signal strength, in percent.",
            "type": "integer",
            "nullable": true,
            "example": 95
          },
          "snr_raw": {
            "description": "Signal-noise ratio, as a raw 16-bit number received from DVB API. It is the ratio of signal power to the noise power.\n",
            "type": "integer",
            "nullable": true,
            "example": 894
          },
          "snr": {
            "description": "Signal-noise ratio, in percent. It is the ratio of signal power to the noise power. \n",
            "type": "integer",
            "nullable": true,
            "example": 1
          },
          "has_signal": {
            "description": "Whether a signal is detected above the normal noise level.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "has_carrier": {
            "description": "Carrier detected in signal.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "has_viterbi": {
            "description": "DVB signal was locked at Viterbi decoder stage.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "has_sync": {
            "description": "Synchronization bytes detected.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "has_lock": {
            "description": "DVB signal was successfully locked.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "has_timedout": {
            "description": "The signal was not locked within the last about 2 seconds.",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "has_reinit": {
            "description": "The frontend was reinitialized, the application is recommended to reset DiSEqC, tone and parameters.\n",
            "type": "boolean",
            "nullable": true,
            "example": false
          },
          "has_rate": {
            "description": "Input rate is sufficient (900 bps or greater). Used for capturing from DekTec ASI cards.\n",
            "type": "boolean",
            "nullable": true,
            "example": true
          }
        }
      },
      "dvb_fec": {
        "type": "string",
        "enum": [
          "1_2",
          "2_3",
          "2_5",
          "3_4",
          "3_5",
          "4_5",
          "5_6",
          "6_7",
          "7_8",
          "8_9",
          "9_10"
        ]
      },
      "decklink_config": {
        "type": "object",
        "properties": {}
      },
      "event_sink_filter": {
        "type": "object",
        "additionalProperties": {
          "description": "A set of filters for event fields.\nYou can specify an event field and its possible values.\n",
          "type": "array",
          "items": {
            "type": "string",
            "example": "stream_stopped"
          }
        }
      },
      "event_sink_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "event_sink_name",
            "description": "Globally unique event sink name.",
            "x-primary-key": true,
            "example": "no_video"
          },
          "url": {
            "type": "string",
            "description": "Path where events are sent.\n\n* For event handler, it is the URL of an HTTP handler or the path to a lua script:  `http://URL`, `https://URL`, or `path_to_lua_script.lua`.\n* For event logging, it is the path to a log file (human-readable text file or JSON): `log://path_to_log_file.log` or `jsonlog://path_to_log_file.json`.\n",
            "nullable": true,
            "example": "jsonlog:///var/log/events-json.log",
            "pattern": "^(log|jsonlog|http|https|lua|pid)://.+$"
          },
          "buffer": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "integer"
              }
            ],
            "default": true,
            "example": true,
            "deprecated": true,
            "x-delete-at": 22.11,
            "description": "If this option is enabled, Flussonic accumulates events in a special buffer.\nIf the receiving HTTP server or script does not respond, then Flussonic periodically retries sending them untill it gets the respond.\n"
          },
          "only": {
            "description": "If specified, only the events that match **every** filter in the filter set will be passed to the event sink target.\n\nThat is, if even one of the conditions is not satisfied, an event will **not** be processed. \nEach filter (condition) has several possible values. For an event to satisfy the condition, \nan event should match **any** of the specified values, not all of them.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/event_sink_filter"
            },
            "nullable": true
          },
          "except": {
            "description": "If specified, only the events that match **every** filter in the filter set will not be be passed to the event sink target.\n\nThat is, if even one of the conditions is not satisfied, an event will be processed.\n\nEach filter (condition) has several possible values. For an event to satisfy the condition, \nan event should match **any** of the specified values, not all of them.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/event_sink_filter"
            },
            "nullable": true
          },
          "throttle_delay": {
            "description": "The delay (in seconds) before sending an event to the sink after saving it into the buffer. \nThis parameter allows to lower frequency of sending events.\n\nIf there are more than 100 events in the buffer, all of them will be sent to the sink without any delay.  \n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "example": 1
          },
          "max_size": {
            "description": "Maximum size of a log file. \n\nWhen this limit is reached, log rotation is performed: the oldest events will be overridden by later data.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 10000
          },
          "max_depth": {
            "description": "Maximal number of log files with events (JSON or text) that can be stored on a disk.\n\nWhen this limit is reached, log rotation is performed: the oldest files will be overridden by later data.\n",
            "type": "integer",
            "nullable": true,
            "example": 100
          },
          "resend_limit": {
            "description": "If an error occurs (`HTTP 500` or any other error), then *Flussonic* will try to buffer events and send them later.\n\nThe option defines the **number** of events to keep in memory for further delivery.\n\nThe default value is `unlimited`.\n",
            "type": "integer",
            "nullable": true,
            "example": 1000
          },
          "resend_timeout": {
            "description": "How often *Flussonic* will try to resend non-confirmed events to the handler (in seconds).",
            "type": "integer",
            "nullable": true,
            "example": 10
          },
          "resend_notifications_limit": {
            "description": "Maximum number of events in a buffer accumulated when the event handler does not respond.",
            "type": "integer",
            "nullable": true,
            "deprecated": true,
            "x-alias": "resend_limit"
          },
          "resend_notifications_timeout": {
            "description": "Timeout for attempts to resend events accumulated when the event handler did not respond.",
            "type": "integer",
            "nullable": true,
            "deprecated": true,
            "x-alias": "resend_timeout"
          },
          "verbose": {
            "description": "The level of logging according to event importance.",
            "allOf": [
              {
                "$ref": "#/components/schemas/loglevel"
              }
            ],
            "nullable": true,
            "deprecated": true,
            "x-alias": "level"
          },
          "level": {
            "allOf": [
              {
                "$ref": "#/components/schemas/loglevel"
              }
            ],
            "nullable": true,
            "description": "Specify logging level for this sink. Anything more verbose than it will not get into this sink.\n"
          },
          "extra": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true,
            "description": "Some additional options."
          }
        },
        "required": [
          "name",
          "url"
        ]
      },
      "streamer_event1": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/server_starting"
          },
          {
            "$ref": "#/components/schemas/server_started"
          },
          {
            "$ref": "#/components/schemas/change_server_id"
          },
          {
            "$ref": "#/components/schemas/presence_connected"
          },
          {
            "$ref": "#/components/schemas/presence_disconnected"
          },
          {
            "$ref": "#/components/schemas/source_opened"
          },
          {
            "$ref": "#/components/schemas/source_connected"
          },
          {
            "$ref": "#/components/schemas/source_started"
          },
          {
            "$ref": "#/components/schemas/source_updated"
          },
          {
            "$ref": "#/components/schemas/source_closed"
          },
          {
            "$ref": "#/components/schemas/stream_opened"
          },
          {
            "$ref": "#/components/schemas/stream_updated"
          },
          {
            "$ref": "#/components/schemas/stream_closed"
          },
          {
            "$ref": "#/components/schemas/play_opened"
          },
          {
            "$ref": "#/components/schemas/play_started"
          },
          {
            "$ref": "#/components/schemas/play_updated"
          },
          {
            "$ref": "#/components/schemas/play_closed"
          },
          {
            "$ref": "#/components/schemas/push_opened"
          },
          {
            "$ref": "#/components/schemas/push_connected"
          },
          {
            "$ref": "#/components/schemas/push_started"
          },
          {
            "$ref": "#/components/schemas/push_updated"
          },
          {
            "$ref": "#/components/schemas/push_closed"
          },
          {
            "$ref": "#/components/schemas/push_blocked"
          },
          {
            "$ref": "#/components/schemas/push_restored"
          },
          {
            "$ref": "#/components/schemas/chassis_connected"
          },
          {
            "$ref": "#/components/schemas/chassis_disconnected"
          },
          {
            "$ref": "#/components/schemas/chassis_reboot"
          },
          {
            "$ref": "#/components/schemas/chassis_shutdown"
          },
          {
            "$ref": "#/components/schemas/chassis_starting"
          },
          {
            "$ref": "#/components/schemas/chassis_tftp_ready"
          },
          {
            "$ref": "#/components/schemas/chassis_firmware_remount_rw"
          },
          {
            "$ref": "#/components/schemas/chassis_firmware_downloaded_file"
          },
          {
            "$ref": "#/components/schemas/chassis_firmware_downloaded_manifest"
          },
          {
            "$ref": "#/components/schemas/chassis_firmware_remount_ro"
          },
          {
            "$ref": "#/components/schemas/chassis_firmware_updated_bootloader"
          },
          {
            "$ref": "#/components/schemas/chassis_coder_turned_off"
          },
          {
            "$ref": "#/components/schemas/chassis_coder_disconnected"
          },
          {
            "$ref": "#/components/schemas/chassis_coder_turned_on"
          },
          {
            "$ref": "#/components/schemas/chassis_dhcp_request"
          },
          {
            "$ref": "#/components/schemas/chassis_tftp_request"
          },
          {
            "$ref": "#/components/schemas/chassis_nfs_mounted"
          },
          {
            "$ref": "#/components/schemas/chassis_ntp_request"
          },
          {
            "$ref": "#/components/schemas/chassis_coder_starting"
          },
          {
            "$ref": "#/components/schemas/chassis_coder_connected"
          },
          {
            "$ref": "#/components/schemas/transcoder_device_insufficient_resources"
          },
          {
            "$ref": "#/components/schemas/webrtc_play_prober_timeout"
          },
          {
            "$ref": "#/components/schemas/webrtc_play_prober_wrong_interval"
          },
          {
            "$ref": "#/components/schemas/ad_injected"
          },
          {
            "$ref": "#/components/schemas/multiplexer_pid_on"
          },
          {
            "$ref": "#/components/schemas/multiplexer_pid_off"
          }
        ],
        "discriminator": {
          "propertyName": "event"
        }
      },
      "event_default": {
        "type": "object",
        "properties": {
          "utc_ms": {
            "type": "integer",
            "format": "milliseconds",
            "nullable": true,
            "description": "The time of the event registration on the server.\n"
          },
          "event_id": {
            "type": "integer",
            "nullable": true,
            "description": "Event identifier.\n"
          }
        }
      },
      "event_media": {
        "type": "object",
        "properties": {
          "media": {
            "type": "string",
            "nullable": true,
            "description": "The name of the stream or file where the event was captured.\n"
          },
          "submedia": {
            "description": "Some additional info on the media, may vary depending on the media type.\n",
            "type": "string",
            "nullable": true
          }
        }
      },
      "event_session": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "format": "session_token",
            "nullable": true,
            "description": "Token provided by the client.",
            "example": "zGAFxLkoWluO1pG7_nJmQAbCnM5"
          },
          "duration": {
            "description": "Duration of the session.",
            "type": "integer",
            "format": "seconds",
            "nullable": true
          },
          "referer": {
            "type": "string",
            "format": "url",
            "nullable": true,
            "description": "Referer HTTP header or its analog for other protocols.",
            "example": "http://my-tv-portal.local/hockey1"
          },
          "user_agent": {
            "type": "string",
            "format": "user_agent",
            "nullable": true,
            "description": "Client's user agent for selected protocol.",
            "example": "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36"
          },
          "query_string": {
            "type": "string",
            "nullable": true,
            "description": "Full query string of initial request of the session."
          }
        }
      },
      "event_play": {
        "type": "object",
        "properties": {
          "country": {
            "description": "The country determined from the user's IP address.",
            "type": "string",
            "nullable": true
          },
          "user_name": {
            "description": "User-provided original stream/VOD name.",
            "type": "string",
            "nullable": true
          },
          "user_id": {
            "description": "User ID provided by the authorization backend like Middleware, your billing, or web portal.",
            "type": "string",
            "nullable": true
          }
        }
      },
      "server_starting": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Server started booting."
              },
              "version": {
                "type": "string",
                "nullable": true
              },
              "full_version": {
                "type": "string",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "server_started": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Server started successfully."
              },
              "previous_state": {
                "$ref": "#/components/schemas/previous_server_state",
                "nullable": true
              },
              "version": {
                "type": "string"
              },
              "instance_id": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "change_server_id": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Change the server ID."
              },
              "old": {
                "type": "string"
              },
              "instance_id": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "presence_connected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Presence connected."
              },
              "flush": {
                "type": "integer",
                "nullable": true
              },
              "ip": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "presence_disconnected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Presence disconnected."
              },
              "reason": {
                "type": "string",
                "x-atom": true,
                "nullable": true
              },
              "ip": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "source_opened": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Source opened."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "priority": {
                "type": "integer",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "source_connected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Source connected."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "priority": {
                "type": "integer",
                "nullable": true
              },
              "status": {
                "type": "object",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "source_started": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Source started."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "priority": {
                "type": "integer",
                "nullable": true
              },
              "dts": {
                "type": "number",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "source_updated": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Source updated."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "priority": {
                "type": "integer",
                "nullable": true
              },
              "bitrate": {
                "type": "number",
                "format": "speed",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "source_closed": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Source closed."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "priority": {
                "type": "integer",
                "nullable": true
              },
              "bitrate": {
                "type": "number",
                "format": "speed",
                "nullable": true
              },
              "reason": {
                "type": "object",
                "nullable": true
              },
              "limit": {
                "type": "integer",
                "nullable": true
              },
              "count": {
                "type": "integer",
                "nullable": true
              },
              "client_count": {
                "type": "integer",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "stream_opened": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Stream opened."
              }
            }
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "stream_updated": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Stream updated."
              },
              "reason": {
                "type": "string",
                "nullable": true,
                "x-atom": true
              },
              "sub_id": {
                "type": "string",
                "format": "uuid",
                "nullable": true
              },
              "sub_bytes": {
                "type": "integer",
                "format": "bytes",
                "nullable": true
              },
              "sub_opened_at": {
                "type": "integer",
                "format": "milliseconds",
                "nullable": true
              },
              "bytes_in": {
                "type": "integer",
                "format": "bytes",
                "nullable": true
              },
              "bytes_out": {
                "type": "integer",
                "format": "bytes",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "stream_closed": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Stream closed."
              },
              "reason": {
                "type": "string",
                "nullable": true,
                "x-atom": true
              },
              "bytes_out": {
                "type": "integer",
                "format": "bytes",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "play_opened": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Play session opened."
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_play"
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "play_started": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Play session started."
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_play"
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "play_updated": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Play session updated."
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_play"
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "play_closed": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Play session closed."
              },
              "reason": {
                "type": "object",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/event_play"
          }
        ]
      },
      "push_opened": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push opened."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "retry_count": {
                "type": "integer",
                "nullable": true
              },
              "retry_limit": {
                "type": "integer",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_connected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push connected."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "status": {
                "type": "object",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_started": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push started."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_updated": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push updated."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_closed": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push closed."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              },
              "reason": {
                "type": "object",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_blocked": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push blocked."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "push_restored": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Push restored."
              },
              "url": {
                "type": "string",
                "format": "url",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_session"
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_coder_connected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis is starting."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_coder_disconnected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Coder's chassis disconnected."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_coder_starting": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Coder's chassis starting."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_coder_turned_off": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Coder's chassis turned off."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_coder_turned_on": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Coder's chassis turned on."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_connected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis is connected."
              },
              "node": {
                "type": "string",
                "x-atom": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_dhcp_request": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis DHCP request."
              },
              "coder": {
                "type": "integer"
              },
              "ethernet": {
                "type": "string"
              },
              "boot_file": {
                "type": "string"
              },
              "serial_number": {
                "type": "string"
              },
              "ip": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_disconnected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis is disconnected."
              },
              "node": {
                "type": "string",
                "x-atom": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_firmware_downloaded_file": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Firmware's chassis downloaded file."
              },
              "path": {
                "type": "string",
                "format": "disk_path"
              },
              "duration": {
                "type": "integer",
                "format": "milliseconds"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_firmware_downloaded_manifest": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Firmware's chassis downloaded manifest."
              },
              "channel": {
                "type": "string"
              },
              "version": {
                "type": "string",
                "format": "chassis_version"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_firmware_remount_ro": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Firmware's chassis remount ro."
              },
              "path": {
                "type": "string",
                "format": "disk_path",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_firmware_remount_rw": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Firmware's chassis remount rw."
              },
              "path": {
                "type": "string",
                "format": "disk_path",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_firmware_updated_bootloader": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Firmware's chassis updated bootloader."
              },
              "channel": {
                "type": "string"
              },
              "version": {
                "type": "string",
                "format": "chassis_version"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_nfs_mounted": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis NFS mounted."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_ntp_request": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis NTP request."
              },
              "coder": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_reboot": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis reboot."
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_shutdown": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis shut down."
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_starting": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis is starting."
              },
              "version": {
                "type": "string"
              },
              "full_version": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_tftp_ready": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis TFTP is ready."
              },
              "coder": {
                "type": "integer",
                "nullable": true
              },
              "path": {
                "type": "string",
                "nullable": true
              },
              "size": {
                "type": "integer",
                "format": "bytes",
                "nullable": true
              },
              "speed": {
                "type": "integer",
                "format": "speed",
                "nullable": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "chassis_tftp_request": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Chassis TFTP request."
              },
              "coder": {
                "type": "integer"
              },
              "path": {
                "type": "string",
                "format": "disk_path"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "transcoder_device_insufficient_resources": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string"
              },
              "deviceid": {
                "type": "integer"
              },
              "reason": {
                "type": "string"
              },
              "decoder": {
                "type": "boolean",
                "description": "Decoder overload indicator",
                "x-private": true
              },
              "encoder": {
                "type": "boolean",
                "description": "Encoder overload indicator",
                "x-private": true
              },
              "resize": {
                "type": "boolean",
                "description": "Resize overload indicator",
                "x-private": true
              },
              "audio": {
                "type": "boolean",
                "description": "Audio transcoder overload indicator",
                "x-private": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "webrtc_play_prober_timeout": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "WebRTC Play Prober timeout"
              }
            }
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "webrtc_play_prober_wrong_interval": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "WebRTC Play Prober wrong interval"
              },
              "direction": {
                "type": "string",
                "enum": [
                  "sending",
                  "receiving"
                ]
              },
              "value": {
                "type": "integer"
              }
            }
          },
          {
            "$ref": "#/components/schemas/session_generic"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_default"
          }
        ]
      },
      "ad_injected": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Advertisement injected."
              },
              "path": {
                "type": "string",
                "description": "The path to the advertising file in a VOD location."
              },
              "placement": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ad_placement"
                  }
                ]
              },
              "duration": {
                "type": "integer",
                "format": "seconds",
                "description": "The advertising file duration."
              },
              "midroll_insert_by": {
                "nullable": true,
                "type": "string",
                "enum": [
                  "interval",
                  "splicing"
                ],
                "description": "When to perform midrolls.\nIf your stream has SCTE35 or SCTE104 you may opt to use them.\nBy default ads are inserted on regular intervals\n"
              },
              "session_id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier (or UUID) of the session.",
                "example": "61942414-8c15-4809-8bb6-adf1ae846027"
              },
              "dts": {
                "type": "integer",
                "format": "utc_ms",
                "description": "First advertising keyframe's DTS",
                "example": 1655362349383
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          },
          {
            "$ref": "#/components/schemas/event_media"
          },
          {
            "$ref": "#/components/schemas/event_play"
          }
        ]
      },
      "multiplexer_pid_on": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Pid is added to the output multiplexed stream"
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          },
          {
            "$ref": "#/components/schemas/event_media"
          }
        ]
      },
      "multiplexer_pid_off": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "event": {
                "type": "string",
                "description": "Pid is dropped from the output multiplexed stream"
              },
              "reason": {
                "type": "string",
                "nullable": true,
                "x-atom": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/event_default"
          },
          {
            "$ref": "#/components/schemas/event_media"
          }
        ]
      },
      "auth_backend_url": {
        "type": "object",
        "properties": {
          "url": {
            "description": "The URL of an HTTP backend.      \n",
            "example": "http://stalker-1.iptv.net/auth.php",
            "type": "string"
          }
        },
        "required": [
          "url"
        ]
      },
      "auth_backend_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "auth_backend_name",
            "description": "Globally unique [`auth_backend`](https://flussonic.com/doc/authorization/authorization-configurator/) name.",
            "x-primary-key": true
          },
          "allow_tokens": {
            "description": "Explicit list of tokens that give access to the content without any other checks.\n",
            "example": [
              "test_token1",
              "test_token2"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "deny_tokens": {
            "description": "Explicit list of tokens that deny access to the content and stop any other checks.\n",
            "example": [
              "test_token3",
              "test_token4"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "allow_ips": {
            "description": "Explicit list of IP-addresses or subnet masks that have access to the content without any other checks.\n",
            "example": [
              "127.0.0.1",
              "10.10.0.0/24"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "deny_ips": {
            "description": "Explicit list of IP-addresses or subnet masks that are banned from accessing the content.      \n",
            "example": [
              "8.8.8.8",
              "10.10.0.0/24"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "allow_countries": {
            "description": "Explicit list of countries (two-letter country codes according to ISO 3166-1) that have access to the content without any other checks.\nFlussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses. \nNew releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.\nTherefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/geoip/"
            },
            "example": [
              "RU",
              "US"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "deny_countries": {
            "description": "Explicit list of countries (two-letter country codes according to ISO 3166-1) that are banned from accessing the content.\nFlussonic uses the MaxMind GeoLite2 Country database to map a country to a block of IP addresses. \nNew releases of GeoIP2 databases come out more often than the releases of Flussonic server, so sometimes the used database can become outdated.\nTherefore we recommend you to install a separate GeoIP2 library and set up Flussonic to use it.\n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/geoip/"
            },
            "example": [
              "RU",
              "GB"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "allow_uas": {
            "description": "Explicit list of user agents (set-top boxes or browsers) that have access to the content without any other checks.    \n",
            "example": [
              "AppleWebKit/533.3 (KHTML, like Gecko)",
              "VLC/3.0.8 LibVLC/3.0.8"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "deny_uas": {
            "description": "The list of user agents (set-top boxes or browsers) that are banned from accessing the content.      \n",
            "example": [
              "Mobile Safari/533.3",
              "VLC/3.0.8 LibVLC/3.0.8"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "backends": {
            "description": "URL(s) of the HTTP backend(s).",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/auth_backend_url"
            },
            "nullable": true
          },
          "allow_default": {
            "description": "This option defines the default behavior in the case when all backends are not responding (usually, because of errors in HTTP responses) and the session is not started yet.\nIf this option is enabled, all clients or devices except those listed in `deny` option will have access to the content.\nIf this option is disabled, all clients or devices except those listed in `allow` option will not have access to the content. \n",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/authorization/authorization-configurator/#the-allow-default-option"
            },
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "name"
        ]
      },
      "cache_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "cache_name",
            "description": "Globally unique cache name.",
            "externalDocs": {
              "description": "Find more information here.",
              "url": "https://flussonic.com/doc/vod-file-broadcasting/cache/"
            },
            "x-primary-key": true,
            "example": "cache1"
          },
          "path": {
            "description": "The path where the files from the cloud or HTTP are cached to speed up broadcasting.",
            "type": "string",
            "format": "disk_path",
            "nullable": true,
            "example": "/storage/cache"
          },
          "misses": {
            "description": "The number of requests necessary for a file to be cached.",
            "type": "integer",
            "nullable": true,
            "example": 3
          },
          "storage_limit": {
            "description": "Maximum disk consumption in bytes. \nWhen this limit is reached, the oldest files will be overridden by later files.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "example": 400000
          },
          "expiration": {
            "description": "A period (in seconds) back from the current moment during which the files are stored.\nAs time goes, the files which are older than this period are being overridden by the later files.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "example": 604800
          },
          "disk_limit": {
            "description": "Maximum disk consumption in bytes. \nWhen this limit is reached, the oldest files will be overridden by later files.\n",
            "type": "integer",
            "format": "bytes",
            "nullable": true,
            "deprecated": true,
            "x-alias": "storage_limit",
            "x-delete-at": "21.12"
          },
          "time_limit": {
            "description": "A period (in seconds) back from the current moment during which the files are stored.\nAs time goes, the files which are older than this period are being overridden by the later files.\n",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "deprecated": true,
            "x-alias": "expiration",
            "x-delete-at": "21.12"
          }
        },
        "required": [
          "name"
        ]
      },
      "http_proxy_config": {
        "type": "object",
        "properties": {
          "prefix": {
            "type": "string",
            "format": "media_name",
            "x-primary-key": true,
            "description": "HTTP prefix that will be intercepted by this http proxy configuration\n"
          },
          "url": {
            "type": "string",
            "format": "url",
            "description": "Upstream url\n"
          },
          "mainpage": {
            "type": "boolean",
            "default": false,
            "description": "If this flag is set, then streamer will redirect from \"/\" to this proxy configuration.\n"
          }
        },
        "required": [
          "prefix",
          "url"
        ]
      },
      "dynafile_config": {
        "type": "object",
        "properties": {
          "cache": {
            "description": "Cache configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/cache_spec"
              }
            ],
            "nullable": true
          },
          "transcoder": {
            "description": "Transcoder configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/transcoder_opts"
              }
            ],
            "nullable": true
          }
        }
      },
      "network_addr": {
        "type": "string",
        "minLength": 1
      },
      "chassis_config": {
        "type": "object",
        "properties": {
          "api_port": {
            "description": "Private port for API requests to the chassis from coders.",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "readOnly": true
          },
          "auto_reboot": {
            "description": "Shows if auto restart of coders when (re)starting chassis is enabled.",
            "type": "boolean",
            "default": false,
            "readOnly": true
          },
          "dhcpd_iface": {
            "description": "Network interface for automatic reception of IP address from DHCP server. \nThis interface will be used for launching coders.\n",
            "type": "string",
            "format": "interface_name",
            "readOnly": true
          },
          "dhcpd_port": {
            "description": "Source port for DHCP requests.",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "readOnly": true
          },
          "dhcpd_port_dest": {
            "description": "Destination port for DHCP requests.",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "readOnly": true
          },
          "lcd": {
            "description": "Shows if LCD monitor capabilities are enabled in the firmware.",
            "type": "boolean",
            "default": false,
            "readOnly": true
          },
          "ntpd_iface": {
            "description": "Network interface for NTP daemon.",
            "type": "string",
            "format": "interface_name",
            "readOnly": true
          },
          "ntpd_port": {
            "description": "Port for NTP daemon.",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "readOnly": true
          },
          "tftp_port": {
            "description": "Port for TFTP used for loading program core to the coders.",
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "readOnly": true
          },
          "tftp_root": {
            "description": "TFTP root directory.",
            "type": "string",
            "format": "disk_path",
            "readOnly": true
          },
          "update_channel": {
            "description": "Update channel specified in the config file.",
            "type": "string",
            "readOnly": true
          },
          "firmware_host": {
            "description": "URL for downloading firmware.",
            "type": "string",
            "format": "url",
            "readOnly": true
          },
          "firmware_version": {
            "description": "Firmware version installed on the device.",
            "type": "string",
            "readOnly": true
          },
          "firmware_boot_dir": {
            "description": "Directory to boot the device from. This is also where the firmware is downloaded on updates.",
            "type": "string",
            "format": "disk_path",
            "readOnly": true
          },
          "stats": {
            "description": "Statistics of the chassis connections.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_stats"
              }
            ],
            "readOnly": true
          },
          "restart_coder_timeout": {
            "description": "Timeout for restarting coders.",
            "type": "integer",
            "readOnly": true
          },
          "hostname": {
            "description": "The name of the chassis server.",
            "type": "string",
            "format": "server_name"
          },
          "default_gateway_interface": {
            "description": "If `default_gateway` parameters are set the individual interfaces config, \nthis gateway is only used for checking license and updates. \nOtherwise, it is used as gateway for all traffic.\n",
            "type": "string"
          }
        }
      },
      "chassis_stats": {
        "type": "object",
        "properties": {
          "dhcp": {
            "description": "DHCP statistics.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_dhcpd_stats"
              }
            ]
          },
          "tftp": {
            "description": "TFTP statistics.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_tftp_stats"
              }
            ]
          },
          "ntpd": {
            "description": "NTP daemon statistics.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_ntpd_stats"
              }
            ]
          },
          "model": {
            "description": "The chassis model name.",
            "type": "string"
          },
          "version": {
            "description": "Full version number of the firmware.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_version"
              }
            ],
            "example": "21.09.1-230"
          },
          "next_version": {
            "description": "The latest available version of the firmware, if any.",
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_version"
              }
            ]
          },
          "serial_number": {
            "description": "The serial number of the chassis.",
            "type": "string"
          },
          "hardware_id": {
            "description": "MAC address of the manage0 interface.",
            "type": "string"
          },
          "hostname": {
            "type": "string",
            "description": "Hostname of the server.",
            "example": "coder1.local"
          }
        }
      },
      "chassis_dhcpd_stats": {
        "type": "object",
        "properties": {
          "error": {
            "description": "The error code, if any.",
            "type": "string",
            "enum": [
              "listen_failure",
              "port_busy",
              "no_interface"
            ]
          },
          "leases": {
            "description": "The list of leased IP addresses.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "mac": {
                  "type": "string"
                },
                "ip": {
                  "type": "string"
                },
                "count": {
                  "type": "integer"
                },
                "last_seen_at": {
                  "type": "integer"
                }
              }
            },
            "default": []
          }
        }
      },
      "chassis_tftp_stats": {
        "type": "object",
        "properties": {
          "error": {
            "description": "Error code, if any.",
            "type": "string",
            "enum": [
              "listen_failure",
              "port_busy",
              "no_interface"
            ]
          },
          "file_count": {
            "description": "The number of files sent over TFTP.",
            "type": "integer"
          },
          "sent_bytes": {
            "description": "The number of bytes sent over TFTP.",
            "type": "integer"
          }
        }
      },
      "chassis_ntpd_stats": {
        "type": "object",
        "properties": {
          "port": {
            "description": "The port used for NTP daemon.",
            "type": "integer"
          },
          "requests_count": {
            "description": "The number of requests sent.",
            "type": "integer"
          }
        }
      },
      "chassis_version": {
        "type": "string"
      },
      "server_meta": {
        "type": "string"
      },
      "config_version": {
        "type": "array",
        "items": {
          "type": "integer"
        }
      },
      "previous_server_state": {
        "type": "string",
        "enum": [
          "shutdown",
          "killed",
          "unknown",
          "none",
          "error_reading",
          "unconfigured"
        ]
      },
      "config_path_segment": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "string",
            "x-atom": true
          },
          {
            "type": "integer"
          }
        ]
      },
      "config_error_status": {
        "type": "object",
        "properties": {
          "error": {
            "description": "Short error description.",
            "type": "string",
            "x-atom": true,
            "example": "bad_url"
          },
          "config": {
            "description": "Partial configuration that can be recovered if an error occurs.",
            "type": "object",
            "nullable": true
          },
          "line": {
            "description": "Line number pointing to where an error was detected.",
            "type": "integer",
            "nullable": true,
            "example": 15
          },
          "first_error_line": {
            "description": "If an error takes up to several lines, it is the first line where the error was detected.",
            "type": "integer",
            "nullable": true,
            "example": 14
          },
          "col": {
            "description": "The column number pointing to where the error was detected.",
            "type": "integer",
            "nullable": true,
            "example": 20
          },
          "first_error_col": {
            "description": "Last column with something valid.",
            "type": "integer",
            "nullable": true,
            "example": 5
          },
          "path": {
            "description": "Config path to the erroneous element.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/config_path_segment"
            },
            "nullable": true,
            "example": [
              "streams",
              0,
              "inputs",
              0,
              "url",
              "input_url"
            ]
          },
          "detail": {
            "description": "Some other details that may help to identify the error.",
            "nullable": true,
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "object"
              }
            ]
          }
        }
      },
      "license_type": {
        "type": "string",
        "enum": [
          "undefined",
          "online",
          "usb",
          "network",
          "offline"
        ]
      },
      "partition_stats": {
        "type": "object",
        "properties": {
          "path": {
            "description": "Mount path.",
            "type": "string",
            "format": "disk_path"
          },
          "total_mb": {
            "description": "Total number of megabytes shown by the OS for this partition.",
            "type": "integer",
            "format": "megabytes"
          },
          "usage": {
            "description": "Percentage of usage of this partition.",
            "type": "integer",
            "format": "percents"
          }
        }
      },
      "server_stats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/server_stats_whoami"
          },
          {
            "$ref": "#/components/schemas/server_stats_streamer"
          },
          {
            "$ref": "#/components/schemas/server_stats_network"
          },
          {
            "$ref": "#/components/schemas/cloud_resources"
          }
        ]
      },
      "server_stats_whoami": {
        "type": "object",
        "properties": {
          "server_version": {
            "description": "Package version of the server. Might be simple a number of release like 21.11 or longer if you have a rolling release installed.",
            "type": "string",
            "format": "server_version",
            "nullable": true,
            "example": "21.12"
          },
          "build": {
            "type": "integer",
            "nullable": true,
            "description": "Build version\n"
          },
          "now": {
            "type": "number",
            "format": "utc_ms",
            "description": "Current response time\n"
          },
          "started_at": {
            "description": "Boot time of this instance.",
            "type": "integer",
            "format": "utc",
            "nullable": true,
            "example": 1639337825
          }
        }
      },
      "server_stats_streamer": {
        "type": "object",
        "properties": {
          "config_version": {
            "description": "Current runtime version of config. We do not declare exact structure, but we promise\nthat it will be always comparable and increasing (if server has proper NTP configuration, of course).\nRight now it is a tuple of server start time and incrementing version of config.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/config_version"
              }
            ],
            "nullable": true,
            "example": [
              1636709231,
              4
            ]
          },
          "next_version": {
            "description": "Notification about a newer version in the repository.",
            "type": "string",
            "format": "server_version",
            "nullable": true,
            "example": "22.01"
          },
          "streamer_status": {
            "description": "*Flussonic* will always try to start even if there are severe errors that do not\nallow functioning.\n\n`starting` status means you should wait for some time (not more than\na minute).\n\n`running` status means all configuration was loaded. However, the status does not provide\nan information about your streams and the quality of provided service.\n\nAll other statuses mean there are some severe problems on the server\nthat cannot be repaired by Flussonic itself.\n",
            "type": "string",
            "enum": [
              "no_config",
              "broken_config",
              "license_failure",
              "no_license",
              "starting",
              "running"
            ],
            "nullable": true,
            "example": "running"
          },
          "hostname": {
            "description": "Hostname of your server. Please, use FQDN, do not leave your Linux misconfigured.",
            "type": "string",
            "nullable": true,
            "example": "openapi.flussonic.com"
          },
          "license_txt": {
            "description": "The code of the license applied on the server.",
            "type": "string",
            "nullable": true,
            "example": "uO8v12HJhNXVj5gM"
          },
          "license_type": {
            "description": "The license type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/license_type"
              }
            ],
            "nullable": true
          },
          "id": {
            "description": "Unique runtime ID of this instance. Updated with the restart.",
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "example": "61893b15-75b2-4fcb-b4cf-ae1dd0858ea2"
          },
          "vsaas": {
            "description": "Shows if Flussonic Watcher is enabled in the license.",
            "type": "boolean",
            "nullable": true
          },
          "vsaas_branding": {
            "description": "Shows if Watcher branding is enabled in the license.",
            "type": "boolean",
            "nullable": true
          },
          "vsaas_running": {
            "description": "Shows if Watcher is currently running.",
            "type": "boolean",
            "nullable": true
          },
          "rproxy": {
            "description": "Shows if rproxy is configured.",
            "type": "boolean",
            "nullable": true
          },
          "rproxy_running": {
            "description": "Shows if rproxy is running.",
            "type": "boolean",
            "nullable": true
          },
          "transcoder": {
            "description": "Shows if the server's CPU can be used for transcoding \n(i.e. if the `flussonic-transcoder` package is installed on the server). \n",
            "type": "boolean",
            "nullable": true
          },
          "bandwidth_usage": {
            "description": "Outbound bandwidth usage (load balancing in `usage` mode is based on this value).",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "example": 67
          },
          "total_bandwidth": {
            "description": "Total server bandwidth.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "deprecated": true,
            "x-notice": "duplicate of config total_bandwidth",
            "x-deleted-at": 22.03
          },
          "cpu_usage": {
            "description": "CPU usage on the server.",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "example": 48
          },
          "memory_usage": {
            "description": "Memory usage on the server.",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "example": 27
          },
          "scheduler_load": {
            "description": "Erlang scheduler load.",
            "type": "integer",
            "format": "percents",
            "nullable": true,
            "example": 40
          },
          "uptime": {
            "description": "The server uptime.",
            "type": "integer",
            "format": "seconds",
            "nullable": true,
            "example": 4325502
          },
          "partitions": {
            "description": "The list of disk partitions on the server.",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/partition_stats"
                }
              ]
            },
            "nullable": true
          },
          "transcoder_devices": {
            "description": "Statistics on the devices used for transcoding.",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transcoder_device_stats"
                }
              ]
            },
            "nullable": true
          },
          "text_alerts": {
            "description": "Human-readable format of errors and alerts that need to be fixed. \nProvided by some *Flussonic* subsystems.\n",
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "nullable": true
          },
          "config_error": {
            "description": "Information about errors in the config file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/config_error_status"
              }
            ],
            "nullable": true
          },
          "is_chassis": {
            "description": "The flag shows if Flussonic runs on Flussonic Coder.\n",
            "type": "boolean"
          }
        }
      },
      "server_stats_network": {
        "type": "object",
        "properties": {
          "total_clients": {
            "description": "The number of clients receiving the streams from the server at the moment of request.",
            "type": "integer",
            "nullable": true,
            "example": 2040
          },
          "total_streams": {
            "description": "The number of streams created on the server.",
            "type": "integer",
            "nullable": true,
            "example": 45
          },
          "online_streams": {
            "description": "The number of streams that are ready to be served to the clients.",
            "type": "integer",
            "nullable": true,
            "example": 27
          },
          "opened_files": {
            "description": "The number of opened files.",
            "type": "integer",
            "nullable": true,
            "example": 5
          },
          "input_kbit": {
            "description": "Inbound traffic.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "example": 400300
          },
          "output_kbit": {
            "description": "Outbound traffic.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "example": 500400
          }
        }
      },
      "admin_credentials": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string",
            "nullable": true,
            "description": "Login",
            "example": "secretlogin"
          },
          "password": {
            "type": "string",
            "nullable": true,
            "description": "Password",
            "example": "passw"
          }
        },
        "required": [
          "login",
          "password"
        ]
      },
      "server_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/server_config_base"
          },
          {
            "$ref": "#/components/schemas/server_config_full"
          }
        ]
      },
      "server_config_base": {
        "type": "object",
        "properties": {
          "listeners": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listeners"
              }
            ],
            "nullable": true,
            "description": "The configuration of network listeners."
          },
          "http": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_spec"
                }
              ]
            },
            "default": [],
            "description": "List of HTTP ports or `host:port` pairs that will be used for listening. Deprecated, use listeners object.",
            "example": [
              80
            ],
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "https": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_spec"
                }
              ]
            },
            "default": [],
            "description": "List of HTTP ports or `host:port` pairs specs provided that you have valid certificate and domain name. Deprecated, use listeners object.",
            "example": [
              443
            ],
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "admin_http": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_spec"
                }
              ]
            },
            "default": [],
            "description": "Enable another port for API calls. If enabled, `http` port is **not** used for API calls. Deprecated, use listeners object.",
            "example": [
              2080
            ],
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "admin_https": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/listen_spec"
                }
              ]
            },
            "default": [],
            "description": "Enable `admin_https` port for API calls. Deprecated, use listeners object.",
            "example": [
              2443
            ],
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "rtsp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "RTSP listening port.",
            "example": 554,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "rtsps": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "RTSP(S) listening port. Not a standard thing, but *ffmpeg* can connect to RTSP using SSL.",
            "example": 1554,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "turn": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "TURN port for your WebRTC installation.",
            "example": 3478,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "rtmp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "RTMP port.",
            "example": 1935,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "rtmps": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "RTMPS port.",
            "example": 1937,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "snmp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "SNMP listening port.",
            "example": 2161,
            "deprecated": true,
            "x-delete-at": 23.06
          },
          "srt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "Global SRT listening port. It is possible to use a single port for playback and publishing, but it is not compatible with clients.\nConsider configuring separate ports for playback and publishing for each stream."
          },
          "srt2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/listen_spec"
              }
            ],
            "nullable": true,
            "description": "Global SRT2 listening port. It is not possible to use a single port for playback and publishing.\nConfigure separate ports for playback and publishing for each stream."
          },
          "srt_play": {
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "nullable": true,
            "description": "SRT play configuration with single-port mode. Not supported by many clients, better use per-stream mode."
          },
          "srt2_play": {
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "nullable": true,
            "description": "SRT2 play configuration with single-port mode. Not supported by many clients, better use per-stream mode."
          },
          "srt_publish": {
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "nullable": true,
            "description": "SRT publish configuration with single-port mode. Not supported by many clients, better use per-stream mode."
          },
          "srt2_publish": {
            "allOf": [
              {
                "$ref": "#/components/schemas/srt_config"
              }
            ],
            "nullable": true,
            "description": "SRT2 publish configuration with single-port mode. Not supported by many clients, better use per-stream mode."
          },
          "config_external": {
            "type": "string",
            "format": "url",
            "nullable": true,
            "description": "Specify stream config backend.",
            "example": "http://central.example.com/streamer/api/v3/streamers",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/config_external"
            }
          },
          "geoip": {
            "type": "string",
            "format": "disk_path",
            "nullable": true,
            "description": "Use your own GeoIP database.",
            "example": "/usr/share/GeoIP/GeoLite2-City.mmdb"
          },
          "meta": {
            "description": "Some additional options of the server.",
            "allOf": [
              {
                "$ref": "#/components/schemas/server_meta"
              }
            ],
            "nullable": true,
            "example": "{\"role\": \"transcoder\"}"
          },
          "loglevel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/loglevel"
              }
            ],
            "nullable": true,
            "description": "Raise loglevel to debug if needed.",
            "example": "error"
          },
          "nvidia_monitor": {
            "description": "Enables saving statistics on Nvidia performance.",
            "type": "boolean",
            "nullable": true,
            "example": true
          },
          "total_bandwidth": {
            "description": "Total server bandwidth.",
            "type": "integer",
            "format": "speed",
            "nullable": true,
            "example": 1000000000
          },
          "log_requests": {
            "description": "Enables logging of requests for streams (manifests, segments) and API request.",
            "type": "boolean",
            "nullable": true
          },
          "pulsedb": {
            "description": "Directory to store Pulse statistics.",
            "type": "string",
            "format": "disk_path",
            "nullable": true,
            "example": "/var/run/flussonic/pulsedb"
          },
          "session_log": {
            "description": "Directory to store the session log.",
            "type": "string",
            "format": "disk_path",
            "nullable": true,
            "example": "/var/run/flussonic/session_log"
          },
          "cluster_key": {
            "description": "The cluster key to unite several servers with the same key into a cluster.",
            "type": "string",
            "nullable": true,
            "example": "xS6i6Q3DCc5nEvnu"
          },
          "url_prefix": {
            "description": "This option applies to HLS and DASH protocols, for all streams on the server. \nThe addresses of individual segments within a segment-based playlist will start with the specified prefix.\nThis setting is available in the global part of the config file as well as locally for any individual stream. \nWhen specified at the stream level, it is only valid for this particular stream.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/url_prefix"
              }
            ],
            "nullable": true
          },
          "view_auth": {
            "allOf": [
              {
                "$ref": "#/components/schemas/admin_credentials"
              }
            ],
            "nullable": true,
            "description": "Credentials for access to readonly API functions like getting streams info, status, and statistics.\n"
          },
          "edit_auth": {
            "allOf": [
              {
                "$ref": "#/components/schemas/admin_credentials"
              }
            ],
            "nullable": true,
            "description": "Credentials for administrator access to the server."
          },
          "api_allowed_from": {
            "description": "The list of allowed subnets to accept API requests from.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "cidr"
            },
            "nullable": true
          },
          "stats": {
            "allOf": [
              {
                "$ref": "#/components/schemas/server_stats"
              }
            ],
            "description": "Server runtime stats.",
            "nullable": true
          },
          "auth_token": {
            "type": "string",
            "format": "auth_token",
            "nullable": true,
            "example": "token",
            "description": "Configure key name of query string key-value pair for token authentication\n"
          }
        }
      },
      "server_config_full": {
        "type": "object",
        "properties": {
          "chassis": {
            "allOf": [
              {
                "$ref": "#/components/schemas/chassis_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the chassis."
          },
          "event_sinks": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/event_sink_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of event notifications"
          },
          "auth_backends": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/auth_backend_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of auth backends"
          },
          "vods": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/vod_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of VODs"
          },
          "dvrs": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the DVRs"
          },
          "peers": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/peer_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of peers in the cluster."
          },
          "sources": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/source_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the video sources."
          },
          "transponders": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/transponder_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the transponders."
          },
          "templates": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/template_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the templates."
          },
          "streams": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/stream_config"
                }
              ]
            },
            "default": [],
            "description": "The configuration of the streams."
          },
          "caches": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/cache_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the cache."
          },
          "dvb_cards": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvb_card_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the DVB cards."
          },
          "balancers": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/balancer_config"
                }
              ]
            },
            "nullable": true,
            "description": "The configuration of the balancers."
          },
          "camera_alarm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/camera_alarm_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the camera alarms."
          },
          "rproxy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/rproxy_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the port forwarding."
          },
          "vsaas": {
            "allOf": [
              {
                "$ref": "#/components/schemas/vsaas_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the video surveillance subsystem."
          },
          "vision": {
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the AI analytics subsystem."
          },
          "dynafile": {
            "allOf": [
              {
                "$ref": "#/components/schemas/dynafile_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the Dynafile for watermarking."
          },
          "file_processor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/file_processor_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the file processor."
          },
          "iptv": {
            "allOf": [
              {
                "$ref": "#/components/schemas/iptv_config"
              }
            ],
            "nullable": true,
            "description": "The configuration of the IPTV"
          },
          "decklinks": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/decklink_config"
                }
              ]
            },
            "nullable": true,
            "description": "Configuration of decklink SDI capture cards\n"
          },
          "http_proxies": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/http_proxy_config"
                }
              ]
            },
            "nullable": true,
            "description": "List of HTTP prefixes that can be handled via call to remote http server\n"
          }
        }
      },
      "rproxy_config": {
        "type": "object",
        "properties": {}
      },
      "vsaas_config": {
        "type": "object",
        "properties": {}
      },
      "camera_alarm_config": {
        "type": "object",
        "properties": {}
      },
      "vision_config": {
        "type": "object",
        "properties": {}
      },
      "iptv_config": {
        "type": "object",
        "properties": {
          "database": {
            "description": "DB connection string.",
            "type": "string",
            "nullable": true
          }
        }
      },
      "subscribers_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "subscribers": {
                "items": {
                  "$ref": "#/components/schemas/subscriber_config"
                },
                "type": "array",
                "description": "List of fetched subscribers according to query parameters."
              }
            }
          }
        ]
      },
      "subscriber_config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique identifier of the subscriber.\n",
            "example": "client01"
          },
          "token": {
            "type": "string",
            "description": "Simple static unique token that will be automatically created for the\nsubscriber if not provided.\n\nThis token can be used in play URLs.\n\nShould be URL-friendly.\n",
            "nullable": true,
            "example": "ybBb5CFLqSFYc2"
          },
          "max_sessions": {
            "type": "integer",
            "description": "Limit of simulateously played sessions for this subscriber.\n",
            "nullable": true,
            "example": 3
          },
          "packages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "package_name"
            },
            "default": [],
            "description": "List of available packages of channels for this subscriber.\n\nChannels (streams) are not added directly, only via packages.\n"
          }
        },
        "required": [
          "name"
        ]
      },
      "packages_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "packages": {
                "items": {
                  "$ref": "#/components/schemas/package_config"
                },
                "type": "array",
                "description": "List of fetched packages according to query parameters."
              }
            }
          }
        ]
      },
      "package_config": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The package name.",
            "type": "string"
          },
          "channels": {
            "description": "The list of channels in the package.",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": []
          }
        }
      },
      "cloud_resources": {
        "type": "object",
        "properties": {
          "cpu_units": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "gauge",
            "title": "CPU",
            "description": "The absolute metric to be used for estimating CPU performance and capacity.\nSuppose we have Server A and Server B with different CPUs.\nFor calculating absolute metric we can measure the CPU load on both servers \nkeeping the same set of streams on both servers.\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "ram_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "RAM",
            "description": "Total amount of server RAM in (mega)bytes",
            "x-metric-type": "gauge",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "inputs_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Input Duration",
            "description": "Total duration of all inputs successfully captured since `opened_at`  (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "inputs_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "Input Traffic",
            "x-metric-type": "counter",
            "description": "Total amount of data in all inputs captured since `opened_at`  (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "inputs_bandwidth": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Input Traffic",
            "description": "Downstream bandwidth at the time of the request  (gauge)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoded_streams": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "gauge",
            "title": "Transcoded streams",
            "description": "The number of streams decoded at the time of the request (gauge).\nA reasonable limit to prevent transcoder overload by large amount of transcoded streams\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_total_output_bitrate": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Transcoder Output Bitrate (MBR)",
            "description": "Transcoder's total output bitrate measured at the time of the request (gauge).\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_total_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "gpxps",
            "x-metric-type": "gauge",
            "title": "Transcoder Total Pixelrate",
            "description": "Transcoder's total output measured in gigapixels per second (gpxps)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_sd_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Transcoded SD duration",
            "description": "Seconds of total **output** video transcoded with SD or less resolution. \nIf you have 3 SD profiles running during 100 seconds, this parameter will be 300 seconds. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_sd_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "counter",
            "title": "Transcoded SD bytes",
            "description": "Bytes of total **output** video transcoded with SD or less resolution. \nIf you have 3 SD profiles transcoded into 100 bytes each, this parameter will be 300 bytes. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_sd_bitrate": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Transcoded SD bitrate",
            "description": "Transcoder's SD profile output measured in bits per seconds at the time of the request.\nIf you have 3 SD profiles with 1000 bps each, this parameter will be 3000 bps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_sd_pixels": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "counter",
            "title": "Transcoded SD pixels",
            "description": "Total amount of transcoded pixels in SD profile. Specified in billions.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_sd_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "gpxps",
            "x-metric-type": "gauge",
            "title": "Transcoded SD pixelrate",
            "description": "Transcoder's SD profile output measured in (giga)pixels per second at the time of the request (gauge).\nIf you have 3 SD profiles with 1000 gpxps each, this parameter will be 3000 gpxps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_hd_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Transcoded HD duration",
            "description": "Seconds of total **output** video transcoded with HD or less resolution. \nIf you have 3 HD profiles running during 100 seconds, this parameter will be 300 seconds. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_hd_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "counter",
            "title": "Transcoded HD bytes",
            "description": "Bytes of total **output** video transcoded with HD or less resolution. \nIf you have 3 HD profiles transcoded into 100 bytes each, this parameter will be 300 bytes. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_hd_bitrate": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Transcoded HD bitrate",
            "description": "Transcoder's HD profile output measured in bits per seconds at the time of the request.\nIf you have 3 HD profiles with 1000 bps each, this parameter will be 3000 bps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_hd_pixels": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "counter",
            "title": "Transcoded HD pixels",
            "description": "Total amount of transcoded pixels. Specified in billions. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_hd_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "gpxps",
            "x-metric-type": "gauge",
            "title": "Transcoded HD pixelrate",
            "description": "Transcoder's HD profile output measured in (giga)pixels per second at the time of the request (gauge).\nIf you have 3 HD profiles with 1000 gpxps each, this parameter will be 3000 gpxps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_fhd_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Transcoded FullHD duration",
            "description": "Seconds of total **output** video transcoded with FullHD or less resolution. \nIf you have 3 FullHD profiles running during 100 seconds, this parameter will be 300 seconds. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_fhd_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "counter",
            "title": "Transcoded FullHD bytes",
            "description": "Bytes of total **output** video transcoded with FullD or less resolution. \nIf you have 3 FullHD profiles transcoded into 100 bytes each, this parameter will be 300 bytes. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_fhd_bitrate": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Transcoded FullHD bitrate",
            "description": "Transcoder's FullHD profile output measured in bits per seconds at the time of the request.\nIf you have 3 FullHD profiles with 1000 bps each, this parameter will be 3000 bps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_fhd_pixels": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "counter",
            "title": "Transcoded FullHD pixels",
            "description": "Total amount of transcoded pixels. Specified in billions. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_fhd_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "gpxps",
            "x-metric-type": "gauge",
            "title": "Transcoded FullHD pixelrate",
            "description": "Transcoder's FullHD profile output measured in (giga)pixels per second at the time of the request (gauge).\nIf you have 3 FullHD profiles with 1000 gpxps each, this parameter will be 3000 gpxps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_uhd_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Transcoded UltraHD duration",
            "description": "Seconds of total **output** video transcoded with UltraHD or less resolution. \nIf you have 3 UltraHD profiles running during 100 seconds, this parameter will be 300 seconds. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_uhd_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "counter",
            "title": "Transcoded UltraHD bytes",
            "description": "Bytes of total **output** video transcoded with UltraHD or less resolution. \nIf you have 3 UltraHD profiles transcoded into 100 bytes each, this parameter will be 300 bytes. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_uhd_bitrate": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Transcoded UltraHD bitrate",
            "description": "Transcoder's UltraHD profile output measured in bits per seconds at the time of the request.\nIf you have 3 UltraHD profiles with 1000 bps each, this parameter will be 3000 bps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_uhd_pixels": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "counter",
            "title": "Transcoded UltraHD pixels",
            "description": "Total amount of transcoded pixels. Specified in billions.  (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "transcoder_uhd_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "gpxps",
            "x-metric-type": "gauge",
            "title": "Transcoded UltraHD pixelrate",
            "description": "Transcoder's UltraHD profile output measured in (giga)pixels per second at the time of the request (gauge).\nIf you have 3 UltraHD profiles with 1000 gpxps each, this parameter will be 3000 gpxps. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_storage_io_read": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "DVR io Read",
            "description": "Total bandwidth of all read requests to DVR storage in bytes per second. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_storage_io_write": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "DVR io Write",
            "description": "Total bandwidth of all write requests to DVR storage in bytes per second. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_storage_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "gauge",
            "title": "DVR Stored Duration",
            "description": "The duration of all segments kept on storage at the time of the request \nno matter how many tracks a segment contains. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_storage_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "DVR Stored Bytes",
            "description": "Total bytes of all segments kept on storage at the time of the request. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_recorded_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "DVR Recorded Duration",
            "description": "Total duration of segments recorded into DVR since `opened_at` no matter how many tracks a segment contains (counter).\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_recorded_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "DVR Recorded Bytes",
            "x-metric-type": "counter",
            "description": "Total amount of data in segments recorded into DVR since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_played_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "DVR Playback Duration",
            "description": "Total duration of segments played from DVR since `opened_at` \nno matter how many tracks a played segment contains (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "dvr_played_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "counter",
            "title": "DVR Playback Traffic",
            "description": "Total amount of data in segments played from DVR since `opened_at` \nno matter how many tracks a played segment contains. (counter)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "output_bandwidth": {
            "nullable": false,
            "default": 0,
            "format": "bps",
            "x-metric-type": "gauge",
            "title": "Output Bandwidth",
            "description": "Upstream bandwidth on the time of the request. (gauge)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "playback_total_sessions": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "counter",
            "title": "Playback Sessions",
            "description": "The number of sessions played since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "playback_opened_sessions": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "gauge",
            "title": "Playback Simultaneously Opened Sessions",
            "description": "The number of open sessions at the moment of the request. (gauge)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "playback_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Playback Duration",
            "description": "The number of seconds that viewers have watched since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "playback_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "Playback Traffic",
            "x-metric-type": "counter",
            "description": "The number of bytes downloaded by viewers since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "push_duration": {
            "nullable": false,
            "default": 0,
            "format": "seconds",
            "x-metric-type": "counter",
            "title": "Push Duration",
            "description": "The number of seconds pushed since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "push_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "title": "Push Traffic",
            "x-metric-type": "counter",
            "description": "The number of bytes pushed since `opened_at`. (counter)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "vision_units": {
            "nullable": false,
            "default": 0,
            "x-metric-type": "gauge",
            "title": "Computer Vision",
            "description": "Empirically picked metric and cap for estimated video analytics utilization.\n\nLet's say Nvidia 1080 is able to process 10 streams with face detection,\nso one 1080 GPU has 10 virtual units and one stream utilizes 1 unit. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "vision_gpu_ram_bytes": {
            "nullable": false,
            "default": 0,
            "format": "bytes",
            "x-metric-type": "gauge",
            "title": "Computer Vision GPU RAM",
            "description": "GPU RAM size in bytes (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          },
          "vision_pixelrate": {
            "nullable": false,
            "default": 0,
            "format": "mpps",
            "x-metric-type": "gauge",
            "title": "Computer Vision Pixelrate",
            "description": "Vision module throughput measured in (mega)pixels per second at the moment of the request. (gauge)\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/cloud_resource_usage"
              }
            ]
          }
        }
      },
      "cloud_resource_usage": {
        "type": "integer",
        "description": "Count of consumed resource",
        "example": 100
      },
      "tls_version": {
        "type": "string",
        "oneOf": [
          {
            "title": "TLSv1",
            "const": "tlsv1"
          },
          {
            "title": "TLSv1.1",
            "const": "tlsv1.1"
          },
          {
            "title": "TLSv1.2",
            "const": "tlsv1.2"
          }
        ]
      },
      "streams_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "streams": {
                "items": {
                  "$ref": "#/components/schemas/stream_config"
                },
                "type": "array",
                "description": "List of fetched streams according to the query parameters."
              }
            }
          }
        ]
      },
      "stream_dvr_ranges_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "ranges": {
                "description": "List of DVR ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/dvr_range"
                }
              }
            }
          }
        ]
      },
      "stream_dvr_locks_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "locks": {
                "description": "List of locked DVR ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/dvr_range"
                }
              }
            }
          }
        ]
      },
      "sessions_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "sessions": {
                "type": "array",
                "description": "List of fetched sessions according to query parameters.",
                "items": {
                  "$ref": "#/components/schemas/session"
                }
              }
            }
          }
        ]
      },
      "templates_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "templates": {
                "items": {
                  "$ref": "#/components/schemas/template_config"
                },
                "type": "array",
                "description": "List of templates."
              }
            }
          }
        ]
      },
      "dvb_cards_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "dvb_cards": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/dvb_card_config"
                }
              }
            }
          }
        ]
      },
      "event_sinks_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "event_sinks": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/event_sink_config"
                }
              }
            }
          }
        ]
      },
      "available_events_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "events": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/streamer_event1"
                }
              }
            }
          }
        ]
      },
      "auth_backends_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "auth_backends": {
                "items": {
                  "$ref": "#/components/schemas/auth_backend_config"
                },
                "type": "array"
              }
            }
          }
        ]
      },
      "dvrs_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "dvrs": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/dvr_config"
                }
              }
            }
          }
        ]
      },
      "dvr_disks_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "disks": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/raid_disk_config"
                }
              }
            }
          }
        ]
      },
      "vods_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "vods": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/vod_config"
                }
              }
            }
          }
        ]
      },
      "disk_files_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "files": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/disk_file"
                }
              }
            }
          }
        ]
      },
      "logos_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "logos": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/logo_file"
                }
              }
            }
          }
        ]
      },
      "file_processor_config": {
        "type": "object",
        "properties": {
          "path": {
            "description": "The directory where Flussonic puts output files.",
            "type": "string",
            "format": "disk_path",
            "deprecated": true,
            "nullable": true
          },
          "out": {
            "description": "The directory where Flussonic puts output files.",
            "type": "string",
            "format": "disk_path",
            "deprecated": true,
            "nullable": true,
            "x-alias": "path"
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "scheme": "basic",
        "type": "http"
      },
      "bearerAuth": {
        "bearerFormat": "JWT",
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "paths": {
    "/streams": {
      "get": {
        "operationId": "streams_list",
        "summary": "List streams",
        "description": "This API method is one of the most important in whole API, because it gives the list of all streams,\nincluding:\n\n* configured (may not be running at the moment)\n* running (including those that are created via a template and do not have own disk configuration)\n* remote (available from other servers)\n* only recorded\n\nTogether with the `stream_save` method you can manage streams in Flussonic.\n\nYou can pass all stream configuration options to query string for filtering, not only specified in the parameters.\n\nThis method and `stream_get` will return `effective stream configuration` with all templates, overrides, defaults\nincluded into this response. It is not exactly what you can see in the disk config. If you have configured\nthis stream in the disk file, then the original disk configuration can be found in the field `config_on_disk`.\n\nWhat you get from this API call is not what you write to `stream_save`.\n",
        "parameters": [
          {
            "name": "select",
            "description": "Comma-separated list of fields (including nested) that will be returned.",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "example": "name,inputs,stats,dvr.root",
              "type": "string"
            },
            "style": "form"
          },
          {
            "name": "sort",
            "description": "Composite sort direction.\nDefault sort order is `named_by (config,user,remote)`, `position`, `name`.\n",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "example": "-stats.bitrate,name,position",
              "type": "string"
            },
            "style": "form"
          },
          {
            "name": "limit",
            "description": "Limit select count in collection to N elements.  Default value is 100.",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "example": 100
            },
            "style": "form"
          },
          {
            "name": "cursor",
            "description": "Properly encoded analog of offset, allowing to read next bunch of items. \nWe do not offer common `offset` fields, use please cursor for predictable\nfetching of quickly changing list of items. More information can be found [here](https://flussonic.com/doc/api/flussonic-http-api/#limited-collections-access-cursors)\n",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "JTI0cG9zaXRpb25fZ3Q9MQ=="
            }
          },
          {
            "name": "q",
            "description": "Search pattern for different fields like name, title, urls, etc.",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "somepattern"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/streams_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}": {
      "get": {
        "operationId": "stream_get",
        "summary": "Get one stream",
        "description": "This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.",
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_config"
                }
              }
            },
            "description": "Whole stream"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "put": {
        "operationId": "stream_save",
        "summary": "Save stream",
        "description": "Create or update a stream by its name.\nIf the stream doesn't exists in the disk config, it will be created.\n\nIf you try to update a stream that is started from a template by a user request\nhaving `named_by=user`, a new stream will be created in the disk config.\n\nIf you pass only a partial stream configuration, this field will be updated, not the whole stream.\n\nTo create a new stream the property `name` is required.\n\nPass the `\"$reset\": true` option to replace the stream configuration with the provided one.\n",
        "parameters": [
          {
            "name": "name",
            "description": "stream name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "part",
            "description": "The stream is configured by several origins of configuration. It may be `config_on_disk`\nor temporary runtime `config_override` that can be provided via `on_play` or `on_publish`\nbackend, or edited via this API call if you pass `config_override` to this parameter.\n",
            "in": "query",
            "schema": {
              "default": "config_on_disk",
              "type": "string",
              "enum": [
                "config_override",
                "config_on_disk"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "Partial stream configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_config"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "delete": {
        "operationId": "stream_delete",
        "summary": "Delete the stream",
        "description": "This method allows to delete a single stream. You can delete `config_override` by this API call if you want\nto remove all runtime overrides.\n\nIf you do not specify any `part` parameter, this stream will be deleted from `config_on_disk`\nand if it was `named_by: config`, then it will immediately stop.\n",
        "parameters": [
          {
            "name": "name",
            "description": "stream name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "part",
            "description": "part of config to delete",
            "in": "query",
            "schema": {
              "default": "config_on_disk",
              "type": "string",
              "enum": [
                "config_override",
                "config_on_disk"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/stop": {
      "post": {
        "operationId": "stream_stop",
        "summary": "Stop the stream",
        "description": "Stop the stream with a specified name.\n\nIf the stream is static, it will restart according to existing rules.\n\nThis API call is a replacement for both: stop and restart.\n\nServer cannot restart a stream that was started by user (publish for example),\nbecause it cannot ask user to repeat publishing.\n\nStatic stream declared in config will be started automatically as if it failed\ndue to any bug.\n\nThis is why `restart` is actually a `stop` and maybe `start`, while `start` is made\nby live stream subsystem\n",
        "parameters": [
          {
            "name": "name",
            "description": "Stream name.\n",
            "in": "path",
            "required": true,
            "schema": {
              "example": "demo",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Stopped"
          }
        },
        "tags": [
          "stream-ops"
        ]
      }
    },
    "/streams/{name}/dvr/ranges": {
      "parameters": [
        {
          "description": "Stream name.",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "abc",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "description": "This method allows to get the list of DVR recorded ranges for a stream.",
        "operationId": "stream_dvr_ranges_list",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_dvr_ranges_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "summary": "Get stream recorded dvr ranges",
        "tags": [
          "stream-dvr"
        ]
      },
      "delete": {
        "description": "This method allows to delete a DVR recording in a specified range for a stream.",
        "operationId": "stream_dvr_ranges_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dvr_range"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "The DVR recording for the specified range is deleted."
          }
        },
        "summary": "Delete stream recorded DVR range",
        "tags": [
          "stream-dvr"
        ]
      }
    },
    "/streams/{name}/dvr/locks": {
      "parameters": [
        {
          "description": "Stream name.",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "abc",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "description": "This method allows to get the list of locked DVR ranges for a stream.",
        "operationId": "stream_dvr_locks_list",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_dvr_locks_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "summary": "Get stream locked dvr ranges",
        "tags": [
          "stream-dvr"
        ]
      },
      "post": {
        "description": "This method allows to lock a DVR range for a stream.\nLocking can be useful for the nPVR (Network Personal Video Recorder) service or just for keeping important recordings.\n",
        "operationId": "stream_dvr_locks_save",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dvr_range"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "The specified DVR range is locked."
          }
        },
        "summary": "Lock stream recorded DVR range",
        "tags": [
          "stream-dvr"
        ]
      },
      "delete": {
        "description": "This method allows to unlock a DVR range for a stream.",
        "operationId": "stream_dvr_locks_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dvr_range"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "The specified DVR range is unlocked."
          }
        },
        "summary": "Unlock stream recorded DVR range",
        "tags": [
          "stream-dvr"
        ]
      }
    },
    "/sessions": {
      "get": {
        "operationId": "sessions_list",
        "summary": "List sessions",
        "description": "This method returns list of opened play sessions.\n\nAt this moment sessions are filtered only to `type=play`, however later\nwe may add additional sessions like `publish`, `push`, or `ingest`.\n",
        "parameters": [
          {
            "description": "Comma-separated list of fields (including nested) that will be returned",
            "explode": false,
            "in": "query",
            "name": "select",
            "required": false,
            "schema": {
              "example": "name,bytes,created_at",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Composite sort direction.",
            "explode": false,
            "in": "query",
            "name": "sort",
            "required": false,
            "schema": {
              "example": "-created_at,name",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Limit select count in collection to N elements.",
            "explode": false,
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "integer",
              "example": 100
            },
            "style": "form"
          },
          {
            "description": "Properly encoded analog of offset, allowing to read the next bunch of items. of items",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string",
              "example": "JTI0cG9zaXRpb25fZ3Q9MQ=="
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sessions_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "session"
        ]
      }
    },
    "/sessions/reauth": {
      "post": {
        "operationId": "sessions_reauth",
        "summary": "Invalidate auth backend response cache for sessions of specified stream",
        "description": "Flussonic immediately re-call auth-backend and check if session is still authorized.\nThis will be done for all open sessions.\n",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "description": "Media name",
            "required": true,
            "schema": {
              "type": "string",
              "example": "clock"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stream sessions have been successfully marked for reauth",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/collection_response"
                },
                "example": {
                  "estimated_count": 42
                }
              }
            }
          },
          "404": {
            "description": "Stream is not found by the specified name.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                },
                "example": {
                  "errors": [
                    {
                      "code": "stream_not_found",
                      "status": "404",
                      "title": "Stream not found"
                    }
                  ]
                }
              }
            }
          }
        },
        "tags": [
          "session"
        ]
      }
    },
    "/sessions/{id}": {
      "get": {
        "operationId": "session_get",
        "summary": "Get the session",
        "description": "Get the play session.\n",
        "parameters": [
          {
            "description": "Unique identifier (or UUID) of the session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "example": "61942414-8c15-4809-8bb6-adf1ae846027",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/session"
                }
              }
            },
            "description": "Whole session"
          }
        },
        "tags": [
          "session"
        ]
      },
      "delete": {
        "operationId": "session_delete",
        "summary": "Close the session",
        "description": "Close the play session. The closed session will be available in the sessions history.\n",
        "parameters": [
          {
            "description": "Unique identifier (or UUID) of the session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "example": "61942414-8c15-4809-8bb6-adf1ae846027",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "session"
        ]
      }
    },
    "/templates": {
      "get": {
        "operationId": "templates_list",
        "summary": "List templates",
        "description": "This method allows to get the list of all templates in Flussonic with all their settings.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/templates_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "template"
        ]
      }
    },
    "/templates/{name}": {
      "parameters": [
        {
          "description": "Template name.",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "hd-sports",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "template_get",
        "summary": "Get the template",
        "description": "This method allows to get a single template by name.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/template_config"
                }
              }
            },
            "description": "The whole template configuration."
          }
        },
        "tags": [
          "template"
        ]
      },
      "put": {
        "operationId": "template_save",
        "summary": "Save the template",
        "description": "Create or update a template. \nIf you pass only a partial template configuration, only the passed fields will be updated, not the whole template.\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/template_config"
              }
            }
          },
          "description": "Partial template configuration."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/template_config"
                }
              }
            },
            "description": "Updated template."
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "template"
        ]
      },
      "delete": {
        "operationId": "template_delete",
        "summary": "Delete the template",
        "description": "Delete the template by its name.",
        "responses": {
          "204": {
            "description": "The template is deleted."
          }
        },
        "tags": [
          "template"
        ]
      }
    },
    "/multiplexers/{name}/xmltv_upload": {
      "post": {
        "operationId": "multiplexer_xmltv_upload",
        "summary": "Upload XMLTV files",
        "description": "Upload XMLTV files to multiplexer\n",
        "parameters": [
          {
            "description": "multiplexer name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "file": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  }
                }
              }
            }
          },
          "description": "Multipart XMLTV files upload request"
        },
        "responses": {
          "204": {
            "description": "The XMLTV files were uploaded"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't upload"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Multiplexer not found"
          }
        },
        "tags": [
          "multiplexer"
        ]
      }
    },
    "/dvb_cards": {
      "get": {
        "operationId": "dvb_cards_list",
        "summary": "Get list of DVB cards",
        "description": "This method allows to get the list of all DVB cards configured in Flussonic.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvb_cards_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "dvb"
        ]
      }
    },
    "/dvb_cards/{name}": {
      "get": {
        "operationId": "dvb_card_get",
        "summary": "Get the DVB card",
        "description": "This method allows to get a single DVB card by name.",
        "parameters": [
          {
            "description": "dvb_card name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvb_card_config"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "dvb"
        ]
      },
      "put": {
        "operationId": "dvb_card_save",
        "summary": "Save the DVB card",
        "description": "Create or update a DVB card.\nIf you pass only a partial DVB card configuration, only the passed fields will be updated, not the whole configuration.\n",
        "parameters": [
          {
            "description": "dvb_card name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dvb_card_config"
              }
            }
          },
          "description": "Request"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvb_card_config"
                }
              }
            },
            "description": "Response"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save a DVB card"
          }
        },
        "tags": [
          "dvb"
        ]
      },
      "delete": {
        "operationId": "dvb_card_delete",
        "summary": "Delete the DVB card",
        "description": "Delete the DVB card by its name.",
        "parameters": [
          {
            "description": "dvb_card name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "dvb"
        ]
      }
    },
    "/event_sinks": {
      "get": {
        "operationId": "event_sinks_list",
        "summary": "List event sinks configs",
        "description": "This method allows to get the list of all event sinks (former `notify`) configured in Flussonic.\n\nEach event sink is an instruction for Flussonic to send events to some target. \nIn particular, you can configure sending events to an event handler or writing them to a log file.\n\nEvent sink has its unique name just for management purposes,\nevent filtering instructions and target for sending events.\n",
        "externalDocs": {
          "description": "Find more information here.",
          "url": "https://flussonic.com/doc/api/events-api/"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/event_sinks_list"
                }
              }
            },
            "description": "List of event sinks"
          }
        },
        "tags": [
          "events"
        ]
      }
    },
    "/event_sinks/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "event_sink name",
          "in": "path",
          "required": true,
          "schema": {
            "example": "middleware_logger",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "event_sink_get",
        "summary": "Get one event sink configuration",
        "description": "This method allows to get a single event sink configuration.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/event_sink_config"
                }
              }
            },
            "description": "Whole event_sink  config"
          }
        },
        "tags": [
          "events"
        ]
      },
      "put": {
        "operationId": "event_sink_save",
        "summary": "Save a single event sink configuration",
        "description": "Create or update an event sink configuration by its name.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/event_sink_config"
              }
            }
          },
          "description": "Partial event_sink configuration"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/event_sink_config"
                }
              }
            },
            "description": "Updated event sink configuration"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "events"
        ]
      },
      "delete": {
        "operationId": "event_sink_delete",
        "summary": "Delete an event sink configuration",
        "description": "Delete an event sink configuration by its name.",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "events"
        ]
      }
    },
    "/event_sinks/{name}/events": {
      "get": {
        "operationId": "available_events_list",
        "summary": "Get events from sink configuration",
        "description": "This method allows to get the batch of events from an event sink configuration.\nCurrenly this method is not implemented yet.\nHowever, its schema can be used for getting the list of events with descriptions (see the `event` parameter in the response.)\n",
        "parameters": [
          {
            "name": "name",
            "description": "Globally unique event sink name.",
            "in": "path",
            "required": true,
            "schema": {
              "example": "middleware_logger",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "List of events",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/available_events_list"
                }
              }
            }
          }
        },
        "tags": [
          "events"
        ]
      }
    },
    "/auth_backends": {
      "get": {
        "operationId": "auth_backends_list",
        "summary": "List auth backends",
        "description": "This method allows to get the list of all authorization backends configured in Flussonic.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auth_backends_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "auth"
        ]
      }
    },
    "/auth_backends/{name}": {
      "parameters": [
        {
          "description": "Authorization backend name.",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "middleware_auth",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "auth_backend_get",
        "summary": "Get the auth backend",
        "description": "This method allows to get a single authorization backend.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auth_backend_config"
                }
              }
            },
            "description": "The authorization backend configuration."
          }
        },
        "tags": [
          "auth"
        ]
      },
      "put": {
        "operationId": "auth_backend_save",
        "summary": "Save the auth backend",
        "description": "Create or update an authorization backend. \nIf you pass only a partial configuration, only the passed fields will be updated.\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_backend_config"
              }
            }
          },
          "description": "Partial authorization backend configuration."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auth_backend_config"
                }
              }
            },
            "description": "Updated auth_backend"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "auth"
        ]
      },
      "delete": {
        "operationId": "auth_backend_delete",
        "summary": "Delete the auth backend",
        "description": "Delete the authorization backend by its name.",
        "responses": {
          "204": {
            "description": "The authorization backend is deleted."
          }
        },
        "tags": [
          "auth"
        ]
      }
    },
    "/dvrs": {
      "get": {
        "operationId": "dvrs_list",
        "summary": "List DVR configurations",
        "description": "This method allows to get the whole list of global DVR congifurations.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvrs_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "dvr"
        ]
      }
    },
    "/dvrs/{name}": {
      "get": {
        "operationId": "dvr_get",
        "summary": "Get DVR configuration",
        "description": "This method allows to get a single global DVR configuration.",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvr_config"
                }
              }
            },
            "description": "A single global DVR configuration."
          }
        },
        "tags": [
          "dvr"
        ]
      },
      "put": {
        "operationId": "dvr_save",
        "summary": "Save DVR configuration",
        "description": "Create or update a single global DVR configuration. \nIf you pass only a partial DVR configuration, only the passed fields will be updated, not the whole configuration.\n",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dvr_config"
              }
            }
          },
          "description": "Partial DVR configuration."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvr_config"
                }
              }
            },
            "description": "Updated DVR configuration."
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "dvr"
        ]
      },
      "delete": {
        "operationId": "dvr_delete",
        "summary": "Delete DVR configuration",
        "description": "Delete a single global DVR configuration by its name.",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "The DVR configuration is deleted."
          }
        },
        "tags": [
          "dvr"
        ]
      }
    },
    "/dvrs/{name}/disks": {
      "get": {
        "operationId": "dvr_disks_list",
        "summary": "List the DVR disks",
        "description": "This method allows to get the whole list of disks for a DVR configuration with RAID enabled. \nMore information can be found [here](https://flussonic.com/doc/digital-video-recording-dvr/flussonic-raid-for-dvr/). \n",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvr_disks_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "dvr"
        ]
      }
    },
    "/dvrs/{name}/disks/{path}": {
      "get": {
        "operationId": "dvr_disk_get",
        "summary": "Get the DVR disk",
        "description": "This method allows to get a single DVR disk for a DVR configuration with RAID enabled.",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "The path to a mounted disk. \n",
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "example": "volume1",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/raid_disk_config"
                }
              }
            },
            "description": "The configuration of the DVR disk."
          }
        },
        "tags": [
          "dvr"
        ]
      },
      "put": {
        "operationId": "dvr_disk_save",
        "summary": "Save the DVR disk",
        "description": "Create or update a DVR disk. \nIf you pass only a partial DVR disk configuration, only the passed fields will be updated, not the whole disk configuration.\n",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "The path to a mounted disk. \n",
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "example": "volume4",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/raid_disk_config"
              }
            }
          },
          "description": "Partial DVR disk configuration."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/raid_disk_config"
                }
              }
            },
            "description": "Updated dvr disk"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "dvr"
        ]
      },
      "delete": {
        "operationId": "dvr_disk_delete",
        "summary": "Delete the DVR disk",
        "description": "Delete the DVR disk by its path.",
        "parameters": [
          {
            "description": "DVR configuration name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "The path to a mounted disk. \n",
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "example": "volume4",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "The DVR disk is deleted."
          }
        },
        "tags": [
          "dvr"
        ]
      }
    },
    "/logos": {
      "get": {
        "operationId": "logos_list",
        "summary": "List logos",
        "description": "List logo files",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/logos_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "logo"
        ]
      }
    },
    "/logos/{name}": {
      "parameters": [
        {
          "name": "name",
          "in": "path",
          "required": true,
          "description": "logo path name",
          "schema": {
            "example": "file.png",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "logo_get",
        "summary": "Get the logo",
        "description": "Method allows to fetch single logo file",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/logo_file"
                }
              }
            },
            "description": "Whole logo"
          }
        },
        "tags": [
          "logo"
        ]
      },
      "put": {
        "operationId": "logo_save",
        "summary": "Upload the logo",
        "description": "Upload logo file",
        "requestBody": {
          "description": "Uploaded logo",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/logo_file"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/logo_file"
                }
              }
            },
            "description": "Uploaded logo file"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "logo"
        ]
      },
      "delete": {
        "operationId": "logo_delete",
        "summary": "Delete the logo file",
        "description": "Delete the logo by its path",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "logo"
        ]
      }
    },
    "/vods": {
      "get": {
        "operationId": "vods_list",
        "summary": "List VOD locations",
        "description": "This method allows to get the list of all VOD locations configured in Flussonic.\nVOD location is a virtual filepath used to place files for VOD (Video on Demand) broadcasting.\n",
        "externalDocs": {
          "description": "Find more information here.",
          "url": "https://flussonic.com/doc/vod-file-broadcasting/"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/vods_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "vod"
        ]
      }
    },
    "/vods/opened_files": {
      "get": {
        "operationId": "opened_files_list",
        "summary": "List files in VOD locations which are played by the clients",
        "description": "This method allows to get the list of files in VOD locations which are played by the clients.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/disk_files_list"
                }
              }
            },
            "description": "List of files in the VOD storage"
          }
        },
        "parameters": [
          {
            "name": "prefix",
            "in": "query",
            "required": false,
            "description": "The unique name of VOD location. \nIt is used as a prefix for displaying opened VOD files in this location.\n",
            "schema": {
              "example": "vod",
              "type": "string"
            },
            "style": "form"
          },
          {
            "name": "storage_index",
            "in": "query",
            "required": false,
            "description": "Index of the storage in the VOD location.\nIt is used as a storage_index for displaying opened VOD files in this storage.\n",
            "schema": {
              "example": 0,
              "type": "integer"
            },
            "style": "form"
          },
          {
            "name": "sort",
            "description": "Composite sort direction.\nDefault sort order is `name`.\n",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "example": "-stats.bytes_out",
              "type": "string"
            },
            "style": "form"
          },
          {
            "name": "limit",
            "description": "Limit select count in collection to N elements.  Default value is 100.",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "example": 100
            },
            "style": "form"
          },
          {
            "name": "cursor",
            "description": "A properly encoded equivalent of offset allowing you to read the next bunch of items. \nWe do not offer common `offset` fields, so please use cursor for predictable\nfetching of quickly changing list of items. More information can be found [here](https://flussonic.com/doc/api/flussonic-http-api/#limited-collections-access-cursors)\n",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "JTI0cG9zaXRpb25fZ3Q9MQ=="
            }
          }
        ],
        "tags": [
          "vod"
        ]
      }
    },
    "/vods/{prefix}": {
      "get": {
        "operationId": "vod_get",
        "summary": "Get VOD location",
        "description": "This method allows to get a single VOD location.",
        "parameters": [
          {
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "name": "prefix",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/vod_config"
                }
              }
            },
            "description": "Whole VOD location configuration"
          }
        },
        "tags": [
          "vod"
        ]
      },
      "put": {
        "operationId": "vod_save",
        "summary": "Save VOD location",
        "description": "Create or update a single VOD location.\nIf you pass only a partial VOD location configuration, only the passed fields will be updated, not the whole configuration.\n",
        "parameters": [
          {
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "name": "prefix",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/vod_config"
              }
            }
          },
          "description": "Partial VOD location configuration"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/vod_config"
                }
              }
            },
            "description": "Updated VOD location configuration"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "vod"
        ]
      },
      "delete": {
        "operationId": "vod_delete",
        "summary": "Delete VOD location",
        "description": "Delete a single VOD location by its prefix",
        "parameters": [
          {
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "name": "prefix",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "vod"
        ]
      }
    },
    "/vods/{prefix}/storages/{storage_index}/files": {
      "get": {
        "operationId": "disk_files_list",
        "summary": "List files in a VOD location",
        "description": "This method allows to get the list of all files and folders for a specific storage subpath in a VOD location.",
        "parameters": [
          {
            "name": "prefix",
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "required": true,
            "schema": {
              "example": "vod",
              "type": "string"
            }
          },
          {
            "name": "storage_index",
            "in": "path",
            "description": "The index of the storage in the VOD location.",
            "required": true,
            "schema": {
              "example": 0,
              "type": "integer"
            }
          },
          {
            "name": "folder",
            "in": "query",
            "description": "The folder in the storage to filter the results by.",
            "required": false,
            "schema": {
              "example": "abc",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/disk_files_list"
                }
              }
            },
            "description": "List of files in the VOD storage"
          }
        },
        "tags": [
          "vod"
        ]
      }
    },
    "/vods/{prefix}/storages/{storage_index}/files/{subpath}": {
      "get": {
        "operationId": "disk_file_get",
        "summary": "Get a single VOD file",
        "description": "This method allows to get a single VOD file.",
        "parameters": [
          {
            "name": "prefix",
            "in": "path",
            "required": true,
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "schema": {
              "example": "vod",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "storage_index",
            "in": "path",
            "required": true,
            "description": "Index of the storage in the VOD location.",
            "schema": {
              "example": 0,
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "name": "subpath",
            "in": "path",
            "description": "Subpath to the file in the storage including filename.",
            "required": true,
            "schema": {
              "example": "bunny.mp4",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/disk_file"
                }
              }
            },
            "description": "Whole VOD file configuration."
          }
        },
        "tags": [
          "vod"
        ]
      },
      "put": {
        "operationId": "disk_file_save",
        "summary": "Save a VOD file",
        "description": "Upload a file to the VOD location.",
        "parameters": [
          {
            "name": "prefix",
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "required": true,
            "schema": {
              "example": "vod",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "storage_index",
            "description": "Index of the storage in the VOD location.",
            "in": "path",
            "required": true,
            "schema": {
              "example": 0,
              "type": "integer"
            },
            "style": "simple",
            "explode": false
          },
          {
            "name": "subpath",
            "description": "Subpath to the file in the storage including filename.",
            "in": "path",
            "required": true,
            "schema": {
              "example": "bunny.mp4",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "description": "Streaming VOD file payload.",
          "content": {
            "*/*": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/disk_file"
                }
              }
            },
            "description": "Uploaded VOD file."
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "vod"
        ]
      },
      "delete": {
        "operationId": "disk_file_delete",
        "summary": "Delete a VOD file",
        "description": "Delete a VOD file by its name.",
        "parameters": [
          {
            "name": "prefix",
            "description": "The unique name of VOD location. \nIt is used as a prefix for playing VOD files in this location.\n",
            "in": "path",
            "required": true,
            "schema": {
              "example": "vod",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "storage_index",
            "description": "Index of the storage in the VOD location.",
            "in": "path",
            "required": true,
            "schema": {
              "example": 0,
              "type": "integer"
            },
            "explode": false,
            "style": "simple"
          },
          {
            "name": "subpath",
            "description": "Subpath to the file in the storage including filename.",
            "in": "path",
            "required": true,
            "schema": {
              "example": "bunny.mp4",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "vod"
        ]
      }
    },
    "/chassis/interfaces/{name}": {
      "parameters": [
        {
          "description": "interface name",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "coder1",
            "type": "string"
          },
          "style": "simple"
        }
      ]
    },
    "/chassis/interfaces/{name}/blink": {
      "parameters": [
        {
          "description": "interface name",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "example": "coder1",
            "type": "string"
          },
          "style": "simple"
        }
      ]
    },
    "/chassis/backups/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "backup name",
          "in": "path",
          "required": true,
          "schema": {
            "example": "20210915-231745",
            "type": "string"
          },
          "style": "simple"
        }
      ]
    },
    "/chassis/backups/{name}/restore": {
      "parameters": [
        {
          "name": "name",
          "description": "backup name",
          "in": "path",
          "required": true,
          "schema": {
            "example": "20210915-231745",
            "type": "string"
          },
          "style": "simple"
        }
      ]
    },
    "/config": {
      "get": {
        "operationId": "config_get",
        "summary": "Get server config",
        "description": "Method allows to fetch global server configuration and current runtime status.\n",
        "parameters": [
          {
            "name": "Accept",
            "description": "Ask for `text/plain` to get original text config.\nBy default it will be `application/json`.\n",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "server config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_config"
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Invalid config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_error_status"
                }
              }
            }
          }
        },
        "tags": [
          "config"
        ]
      },
      "put": {
        "operationId": "config_save",
        "summary": "Save server config",
        "description": "Create or update global server configuration.\n",
        "requestBody": {
          "description": "Partial or full server configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/server_config"
              }
            },
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_config"
                }
              }
            }
          },
          "400": {
            "description": "Invalid config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_error_status"
                }
              }
            }
          }
        },
        "tags": [
          "config"
        ]
      },
      "post": {
        "operationId": "config_validate",
        "summary": "Validate config",
        "description": "Just parse and validate config, nothing is saved.\n\nProvide JSON structure or plain text.\n\nTake a look at this example:\n```\ncurl -d 'http 80; stream mystream { input \"\"; }' \\\n  -H 'Content-Type: text/plain' \\\n  -sS http://login:pass@localhost:8080/streamer/api/v3/config | jq\n{\n  \"col\": 34,\n  \"config\": {\n    \"http\": [\n      \"80\"\n    ],\n    \"streams\": [\n      {\n        \"inputs\": [\n          {\n            \"url\": \"\"\n          }\n        ],\n        \"name\": \"mystream\"\n      }\n    ]\n  },\n  \"detail\": \"\",\n  \"error\": \"bad_url\",\n  \"line\": 1,\n  \"path\": [\n    \"streams\",\n    0,\n    \"inputs\",\n    0,\n    \"url\",\n    \"input_url\"\n  ]\n}\n```\n\nYou can see that it is possible to fix error on column 34 where bad, empty url was saved.\n",
        "requestBody": {
          "description": "Partial or full server configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/server_config"
              }
            },
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "http 80;\n\nstream mystream {\n  input udp://239.0.0.1:1234;\n  transcoder vb=2048k ab=64k;\n}\n"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_config"
                }
              }
            }
          },
          "400": {
            "description": "Invalid config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_error_status"
                }
              }
            }
          }
        },
        "tags": [
          "config"
        ]
      }
    },
    "/config/stats": {
      "get": {
        "operationId": "config_stats_get",
        "summary": "Get server stats",
        "description": "Method allows to fetch current runtime status.\n",
        "responses": {
          "200": {
            "description": "server stats",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_stats"
                }
              }
            }
          }
        },
        "tags": [
          "config"
        ]
      }
    },
    "/monitoring/liveness": {
      "get": {
        "operationId": "liveness_probe",
        "summary": "Liveness probe",
        "description": "K8s liveness probe.\n",
        "responses": {
          "200": {
            "description": "Means that server process has started, but doesn't know anything about\nits readiness. Check readiness to validate that server can accept requests.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_stats_whoami"
                }
              }
            }
          }
        },
        "tags": [
          "monitoring"
        ]
      }
    },
    "/monitoring/readiness": {
      "get": {
        "operationId": "readiness_probe",
        "summary": "Readiness probe",
        "description": "K8s readiness probe.\n",
        "responses": {
          "200": {
            "description": "Means that server process is ready to work. All disks are mounted,\nDVR storages opened, etc.\n\nReady for work.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/server_stats_whoami"
                }
              }
            }
          }
        },
        "tags": [
          "monitoring"
        ]
      }
    },
    "/iptv": {
      "get": {
        "operationId": "iptv_get",
        "summary": "IPTV status",
        "description": "Get current status of the trivial IPTV subscriber management system.\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iptv_config"
                }
              }
            },
            "description": "Returns iptv config"
          },
          "404": {
            "description": "IPTV plugin is not configured",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "put": {
        "operationId": "iptv_save",
        "summary": "Save IPTV",
        "description": "Enable or reload IPTV plugin configuration and disk state\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iptv_config"
              }
            }
          },
          "description": "iptv configuration"
        },
        "responses": {
          "200": {
            "description": "Updated iptv config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iptv_config"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "delete": {
        "operationId": "iptv_delete",
        "summary": "Disable IPTV",
        "description": "Disable trivial IPTV plugin, remove it from the config and stop runtime status.\n",
        "responses": {
          "204": {
            "description": "Deleted iptv config"
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/iptv/packages": {
      "get": {
        "operationId": "packages_list",
        "summary": "List all packages",
        "description": "List existing packages. Take a look at operation `package_get` for detailed description\nof package concept.\n",
        "parameters": [
          {
            "description": "Comma-separated list of fields (including nested) that will be returned",
            "explode": false,
            "in": "query",
            "name": "select",
            "required": false,
            "schema": {
              "example": "name,inputs,stats",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Composite sort direction",
            "explode": false,
            "in": "query",
            "name": "sort",
            "required": false,
            "schema": {
              "example": "-stats.bitrate,name,position",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Limit select count in collection to N elements",
            "explode": false,
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "Properly encoded analog of offset, allowing to read next bunch of items",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packages_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/iptv/packages/{name}": {
      "get": {
        "operationId": "package_get",
        "summary": "Get the package",
        "description": "Package is a group of streams (channels), that are provided together\nto customer as a single billing item.\n",
        "parameters": [
          {
            "name": "name",
            "description": "package name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "sports",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/package_config"
                }
              }
            },
            "description": "Whole package"
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "put": {
        "operationId": "package_save",
        "summary": "Save the package",
        "description": "Create or update the package.\n\nPartial configuration can be provided.\n",
        "parameters": [
          {
            "name": "name",
            "description": "package name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "sports",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/package_config"
              }
            }
          },
          "description": "Partial package configuration"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/package_config"
                }
              }
            },
            "description": "Updated package"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "delete": {
        "operationId": "package_delete",
        "summary": "Delete the package",
        "description": "Delete this package with all links to streams and all links to subscribers.\n",
        "parameters": [
          {
            "name": "name",
            "description": "package name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "sports",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/iptv/subscribers": {
      "get": {
        "operationId": "subscribers_list",
        "summary": "List all subscribers",
        "description": "List existing subscribers from database",
        "parameters": [
          {
            "description": "Comma-separated list of fields (including nested) that will be returned",
            "explode": false,
            "in": "query",
            "name": "select",
            "required": false,
            "schema": {
              "example": "name,inputs,stats",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Composite sort direction",
            "explode": false,
            "in": "query",
            "name": "sort",
            "required": false,
            "schema": {
              "example": "-stats.bitrate,name,position",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Limit select count in collection to N elements",
            "explode": false,
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "Properly encoded analog of offset, allowing to read next bunch of items",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/subscribers_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/iptv/subscribers/{name}": {
      "get": {
        "operationId": "subscriber_get",
        "summary": "Get one subscriber",
        "description": "Get the subscriber status.\n",
        "parameters": [
          {
            "name": "name",
            "description": "subscriber name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "client01",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/subscriber_config"
                }
              }
            },
            "description": "Whole subscriber"
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "put": {
        "operationId": "subscriber_save",
        "summary": "Save the subscriber",
        "description": "Create or update the subscriber, identified by his unique name.\nPartial configuration is ok.\n",
        "parameters": [
          {
            "name": "name",
            "description": "subscriber name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "client01",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/subscriber_config"
              }
            }
          },
          "description": "Partial subscriber configuration"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/subscriber_config"
                }
              }
            },
            "description": "Updated subscriber"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "iptv"
        ]
      },
      "delete": {
        "operationId": "subscriber_delete",
        "summary": "Delete the subscriber",
        "description": "Delete the subscriber from database.\nIf he is watching video, all his sessions will be terminated soon.\n",
        "parameters": [
          {
            "name": "name",
            "description": "subscriber name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "client01",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/file_processor/jobs/{id}": {
      "parameters": [
        {
          "name": "id",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    }
  },
  "security": [
    {
      "basicAuth": []
    },
    {
      "bearerAuth": []
    }
  ],
  "servers": [
    {
      "description": "your local installation",
      "url": "http://localhost:8080/streamer/api/v3"
    }
  ],
  "tags": [
    {
      "name": "stream",
      "description": "Managing streams in Flussonic."
    },
    {
      "name": "stream-dvr",
      "description": "Managing DVR archives for streams."
    },
    {
      "name": "stream-ops",
      "description": "Stream operations in runtime"
    },
    {
      "name": "template",
      "description": "Managing templates in Flussonic. A template defines a set of settings to be applied to several streams to provide a more organized and manageable way of configuring streams."
    },
    {
      "name": "dvr",
      "description": "Managing global DVR configurations in Flussonic."
    },
    {
      "name": "auth",
      "description": "Managing authorization backends."
    },
    {
      "name": "session",
      "description": "Manaing play sessions in Flussonic."
    },
    {
      "name": "events",
      "description": "Managing event sinks and events in Flussonic."
    },
    {
      "name": "monitoring",
      "description": "Probes for cluster monitoring"
    },
    {
      "name": "vod"
    },
    {
      "name": "logo",
      "description": "Managing logos in Flussonic."
    },
    {
      "name": "multiplexer"
    },
    {
      "name": "dvb",
      "description": "Managing DVB cards in Flussonic."
    },
    {
      "name": "config"
    },
    {
      "name": "iptv",
      "description": "Manage trivial middleware with user management and channel permissions.\nUse players like Kodi to get access to per-user playlists.\n\nIt is very trivial, just for very trivial operations like giving someone a static\ntoken for accessing content.\n\nDatabase is a static JSON file on disk that is overwritten on each update.\n"
    }
  ]
}
